Microsoft (R) Macro Assembler Version 6.15.8803		    07/25/05 00:49:42
Irvine32 Link Library Source Code         (Irvine32.asm)     Page 1 - 1


				Title Irvine32 Link Library Source Code         (Irvine32.asm)

				Comment @
				To view this file with proper indentation, set your 
					editor's tab stops to columns 5, 11, 35, and 40.

				Recent Updates:
				06/04/05: WaitMsg simplified
				06/08/05: CreateOutputFile, WriteToFile, OpenInputFile, ReadFromFile, CloseFile
				06/10/05: WriteWindowsMsg
				06/13/05: GetCommmandTail
				06/21/05: SetTextColor, GetTextColor
				06/22/05: DumpRegs
				06/05/05: ReadChar
				07/06/05: ReadFromFile
				07/11/05: MsgBox, MsgBoxAsk
				07/15/05: ParseDecimal32, ParseInteger32
				07/19/05: ParseDecimal32, ParseInteger32, ReadHex

				This library was created exlusively for use with the book,
				"Assembly Language for Intel-Based Computers", 4th Edition & 5th Edition,
				by Kip R. Irvine, 2002-2005.

				Copyright 2002-2005, Prentice-Hall Publishing. No part of this file may be
				reproduced, in any form or by any other means, without permission in writing
				from the author or publisher.

				Acknowledgements:
				------------------------------
				Most of the code in this library was written by Kip Irvine.
				Special thanks to Gerald Cahill for his many insights, suggestions, and bug fixes.
				Thanks to Richard Stam for his development of Readkey-related procedures.
				Thanks to James Brink for helping to test the library.

				Alphabetical Listing of Public Procedures
				----------------------------------
				(Unless otherwise marked, all procedures are documented in Chapter 5.)

				CloseFile
				Clrscr
				CreateOutputFile
				Crlf
				Delay
				DumpMem
				DumpRegs
				GetCommandTail
				GetDateTime	Chapter 11
				GetMaxXY
				GetMseconds
				GetTextColor
				Gotoxy
				IsDigit
				MsgBox
				MsgBoxAsk
				OpenInputFile
				ParseDecimal32
				ParseInteger32
				Random32
				Randomize
				RandomRange
				ReadChar
				ReadDec
				ReadFromFile
				ReadHex
				ReadInt
				ReadKey
				ReadKeyFlush
				ReadString
				SetTextColor
				Str_compare	Chapter 9
				Str_copy		Chapter 9
				Str_length	Chapter 9
				Str_trim		Chapter 9
				Str_ucase		Chapter 9
				WaitMsg
				WriteBin
				WriteBinB
				WriteChar
				WriteDec
				WriteHex
				WriteHexB
				WriteInt
				WriteString
				WriteToFile
				WriteWindowsMsg

					          Implementation Notes:
					          --------------------
				1. The Windows Sleep function modifies the contents of ECX.
				2. Remember to save and restore all 32-bit general purpose
				   registers (except EAX) before calling MS-Windows API functions.
				---------------------------------------------------------------------@
				;OPTION CASEMAP:NONE	; optional: force case-sensitivity

				INCLUDE Irvine32.inc	; function prototypes for this library
			      C ; Include file for Irvine32.lib             (Irvine32.inc)
			      C 
			      C ;OPTION CASEMAP:NONE		; optional: make identifiers case-sensitive
			      C 
			      C INCLUDE SmallWin.inc		; MS-Windows prototypes, structures, and constants
			      C .NOLIST
			      C .LIST
			      C 
			      C INCLUDE VirtualKeys.inc
			      C ; VirtualKeys.inc
			      C .NOLIST
			      C .LIST
			      C 
			      C INCLUDE floatio.inc
			      C ; floatio.inc
			      C 
			      C ; For the floatio.lib library, created by 
			      C ; W. A. Barrett, San Jose State University
			      C ; and James Brink, Pacific Lutheran University.
			      C 
			      C ; Used by Permission (July 2005).
			      C 
			      C 
			      C ReadFloat PROTO
			      C WriteFloat PROTO
			      C ShowFPUStack PROTO
			      C 
			      C 
			      C .NOLIST
			      C .LIST
			      C 
				INCLUDE Macros.inc	; macro definitions
			      C .NOLIST
			      C .LIST
			      C 


				;*************************************************************
				;*                          MACROS                           *
				;*************************************************************

				;---------------------------------------------------------------------
				ShowFlag MACRO flagName,shiftCount
					     LOCAL flagStr, flagVal, L1
				;
				; Helper macro.
				; Display a single CPU flag value
				; Directly accesses the eflags variable in Irvine16.asm/Irvine32.asm
				; (This macro cannot be placed in Macros.inc)
				;---------------------------------------------------------------------

				.data
				flagStr DB "  &flagName="
				flagVal DB ?,0

				.code
					push eax
					push edx

					mov  eax,eflags	; retrieve the flags
					mov  flagVal,'1'
					shr  eax,shiftCount	; shift into carry flag
					jc   L1
					mov  flagVal,'0'
				L1:
					mov  edx,OFFSET flagStr	; display flag name and value
					call WriteString

					pop  edx
					pop  eax
				ENDM

				;-------------------------------------------------------------
				CheckInit MACRO
				;
				; Helper macro
				; Check to see if the console handles have been initialized
				; If not, initialize them now.
				;-------------------------------------------------------------
				LOCAL exit
					cmp InitFlag,0
					jne exit
					call Initialize
				exit:
				ENDM

				;*************************************************************
				;*                      SHARED DATA                          *
				;*************************************************************

 = 00000050			MAX_DIGITS = 80

 00000000			.data		; initialized data
 00000000 00			InitFlag DB 0	; initialization flag
 00000001 30 31 32 33 34	xtable BYTE "0123456789ABCDEF"
	   35 36 37 38 39
	   41 42 43 44 45
	   46

 00000000			.data?		; uninitialized data
 00000000 00000000		consoleInHandle  DWORD ?     	; handle to console input device
 00000004 00000000		consoleOutHandle DWORD ?     	; handle to standard output device
 00000008 00000000		bytesWritten     DWORD ?     	; number of bytes written
 0000000C 00000000		eflags  DWORD ?
 00000010  00000050 [		digitBuffer BYTE MAX_DIGITS DUP(?),?
	    00
	   ] 00

 00000061  00000200 [		buffer DB 512 DUP(?)
	    00
	   ]
 00000261 = 00000200		bufferMax = ($ - buffer)
 00000261 00000000		bytesRead DD ?
 00000265 0000 0000 0000	sysTime SYSTEMTIME <>	; system time structure
	   0000 0000 0000
	   0000 0000


				;*************************************************************
				;*                    PUBLIC PROCEDURES                      *
				;*************************************************************

 00000000			.code

				;--------------------------------------------------------
 00000000			CloseFile PROC
				;
				; Closes a file using its handle as an identifier. 
				; Receives: EAX = file handle 
				; Returns: EAX = nonzero if the file is successfully 
				;   closed.
				; Last update: 6/8/2005
				;--------------------------------------------------------

					INVOKE CloseHandle, eax
 00000006  C3				ret
 00000007			CloseFile ENDP


				;-------------------------------------------------------------
 00000007			Clrscr PROC
					LOCAL bufInfo:CONSOLE_SCREEN_BUFFER_INFO
				;
				; Clear the screen by writing blanks to all positions
				; Receives: nothing
				; Returns: nothing
				; Last update: 10/15/02
				;
				; The original version of this procedure incorrectly assumed  the
				; console window dimensions were 80 X 25 (the default MS-DOS screen).
				; This new version writes both blanks and attribute values to each 
				; buffer position. Restriction: Only the first 512 columns of each 
				; line are cleared. The name capitalization was changed to "Clrscr".
				;-------------------------------------------------------------

 = 00000200			MAX_COLS = 512
 00000011			.data
 00000011  00000200 [		blanks BYTE MAX_COLS DUP(' ')			; one screen line
	    20
	   ]
 00000211  00000200 [		attribs WORD MAX_COLS DUP(0)
	    0000
	   ]
 00000611 00000000		lineLength DWORD 0

 00000615 0000 0000		cursorLoc COORD <0,0>
 00000619 00000000		count DWORD ?

 0000000D			.code
 0000000D  60				pushad
					CheckInit
 0000000E  80 3D 00000000 R  1		cmp InitFlag,0
	   00
 00000015  75 05	     1		jne ??0000
 00000017  E8 00000503	     1		call Initialize
 0000001C		     1	??0000:

					; Get the console buffer size and attributes
					INVOKE GetConsoleScreenBufferInfo, consoleOutHandle, ADDR bufInfo
 0000002B  66| 8B 45 EA			mov ax,bufInfo.dwSize.X;
 0000002F  66| A3			mov WORD PTR lineLength,ax
	   00000611 R
					.IF lineLength > MAX_COLS
 00000041  C7 05 00000611 R		  mov lineLength,MAX_COLS
	   00000200
					.ENDIF

					; Fill the attribs array
 0000004B  66| 8B 45 F2			mov ax,bufInfo.wAttributes
 0000004F  8B 0D 00000611 R		mov ecx,lineLength
 00000055  BF 00000211 R		mov edi,OFFSET attribs
 0000005A  F3/ 66| AB			rep stosw

 0000005D  0F B7 4D EC			movzx ecx,bufInfo.dwSize.Y		; loop counter: number of lines
 00000061  51			L1:	push ecx

					; Write a blank line to the screen buffer
					INVOKE WriteConsoleOutputCharacter,
					consoleOutHandle,
					ADDR blanks,		; pointer to buffer
					lineLength,		; number of blanks to write
					cursorLoc,		; first cell coordinates
					ADDR count		; output count

					; Fill all buffer positions with the current attribute
					INVOKE WriteConsoleOutputAttribute,
					  consoleOutHandle,
					  ADDR attribs,		; point to attribute array
					  lineLength,		; number of attributes to write
					  cursorLoc,		; first cell coordinates
					  ADDR count		; output count

 000000A4  66| 83 05			add cursorLoc.Y, 1		; point to the next buffer line
	   00000617 R 01
 000000AC  59				pop ecx
 000000AD  E2 B2			Loop L1

					; Move cursor to 0,0
 000000AF  66| C7 05			mov cursorLoc.Y,0
	   00000617 R
	   0000
					INVOKE SetConsoleCursorPosition, consoleOutHandle, cursorLoc

 000000C9  61				popad
					ret
 000000CC			Clrscr ENDP


				;------------------------------------------------------
 000000CC			CreateOutputFile PROC
				;
				; Creates a new file and opens it in output mode.
				; Receives: EDX points to the filename.
				; Returns: If the file was created successfully, EAX 
				;   contains a valid file handle. Otherwise, EAX  
				;   equals INVALID_HANDLE_VALUE.
				;------------------------------------------------------
					INVOKE CreateFile,
					  edx, GENERIC_WRITE, DO_NOT_SHARE, NULL,
					  CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0
 000000E4  C3				ret
 000000E5			CreateOutputFile ENDP


				;-----------------------------------------------------
 000000E5			Crlf PROC
				;
				; Writes a carriage return / linefeed
				; sequence (0Dh,0Ah) to standard output.
				;-----------------------------------------------------
					CheckInit
 000000E5  80 3D 00000000 R  1		cmp InitFlag,0
	   00
 000000EC  75 05	     1		jne ??0001
 000000EE  E8 0000042C	     1		call Initialize
 000000F3		     1	??0001:
					mWrite <0dh,0ah>	; invoke a macro
 0000061D		     1		.data		
 0000061D 0D 0A 00	     1		??0002 BYTE 0dh,0ah,0	
 000000F3		     1		.code
 000000F3  52		     1		push	edx
 000000F4  BA 0000061D R     1		mov	edx,OFFSET ??0002
 000000F9  E8 00000DFE	     1		call	WriteString
 000000FE  5A		     1		pop	edx
 000000FF  C3				ret
 00000100			Crlf ENDP


				;------------------------------------------------------
 00000100			Delay PROC
				;
				; THIS FUNCTION IS NOT IN THE IRVINE16 LIBRARY
				; Delay (pause) the current process for a given number
				; of milliseconds.
				; Receives: EAX = number of milliseconds
				; Returns: nothing
				; Last update: 7/11/01
				;------------------------------------------------------

 00000100  60				pushad
					INVOKE Sleep,eax
 00000107  61				popad
 00000108  C3				ret

 00000109			Delay ENDP


				;---------------------------------------------------
 00000109			DumpMem PROC
					     LOCAL unitsize:dword, byteCount:word
				;
				; Writes a range of memory to standard output
				; in hexadecimal.
				; Receives: ESI = starting offset, ECX = number of units,
				;           EBX = unit size (1=byte, 2=word, or 4=doubleword)
				; Returns:  nothing
				; Last update: 7/11/01
				;---------------------------------------------------
 00000620			.data
 00000620 20 00			oneSpace   DB ' ',0

 00000622 0D 0A 44 75 6D	dumpPrompt DB 13,10,"Dump of offset ",0
	   70 20 6F 66 20
	   6F 66 66 73 65
	   74 20 00
 00000634 2D 2D 2D 2D 2D	dashLine   DB "-------------------------------",13,10,0
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 2D 2D 2D 2D
	   2D 0D 0A 00

 0000010F			.code
 0000010F  60				pushad

 00000110  BA 00000622 R		mov  edx,OFFSET dumpPrompt
 00000115  E8 00000DE2			call WriteString
 0000011A  8B C6			mov  eax,esi	; get memory offset to dump
 0000011C  E8 00000B41			call  WriteHex
 00000121  E8 FFFFFFBF			call	Crlf
 00000126  BA 00000634 R		mov  edx,OFFSET dashLine
 0000012B  E8 00000DCC			call WriteString

 00000130  66| C7 45 FA			mov  byteCount,0
	   0000
 00000136  89 5D FC			mov  unitsize,ebx
 00000139  83 FB 04			cmp  ebx,4	; select output size
 0000013C  74 07			je   L1
 0000013E  83 FB 02			cmp  ebx,2
 00000141  74 1B			je   L2
 00000143  EB 41			jmp  L3

					; 32-bit doubleword output
 00000145			L1:
 00000145  8B 06			mov  eax,[esi]
 00000147  E8 00000B16			call WriteHex
					mWriteSpace 2
 00000656		     1	.data
 00000656  00000002 [	     1	??0003 BYTE 2 DUP(' '),0
	    20
	   ] 00
 0000014C		     1	.code
 0000014C  52		     1		push	edx
 0000014D  BA 00000656 R     1		mov	edx,OFFSET ??0003
 00000152  E8 00000DA5	     1		call	WriteString
 00000157  5A		     1		pop	edx
 00000158  03 F3			add  esi,ebx
 0000015A  E2 E9			Loop L1
 0000015C  EB 5E			jmp  L4

					; 16-bit word output
 0000015E			L2:
 0000015E  66| 8B 06			mov  ax,[esi]	; get a word from memory
 00000161  66| C1 C8 08			ror  ax,8	; display high byte
 00000165  E8 00000E37			call HexByte
 0000016A  66| C1 C8 08			ror  ax,8	; display low byte
 0000016E  E8 00000E2E			call HexByte
					mWriteSpace 1	; display 1 space
 00000659		     1	.data
 00000659  00000001 [	     1	??0004 BYTE 1 DUP(' '),0
	    20
	   ] 00
 00000173		     1	.code
 00000173  52		     1		push	edx
 00000174  BA 00000659 R     1		mov	edx,OFFSET ??0004
 00000179  E8 00000D7E	     1		call	WriteString
 0000017E  5A		     1		pop	edx
 0000017F  03 75 FC			add  esi,unitsize	; point to next word
 00000182  E2 DA			Loop L2
 00000184  EB 36			jmp  L4

					; 8-bit byte output, 16 bytes per line
 00000186			L3:
 00000186  8A 06			mov  al,[esi]
 00000188  E8 00000E14			call HexByte
 0000018D  66| FF 45 FA			inc  byteCount
					mWriteSpace 1
 0000065B		     1	.data
 0000065B  00000001 [	     1	??0005 BYTE 1 DUP(' '),0
	    20
	   ] 00
 00000191		     1	.code
 00000191  52		     1		push	edx
 00000192  BA 0000065B R     1		mov	edx,OFFSET ??0005
 00000197  E8 00000D60	     1		call	WriteString
 0000019C  5A		     1		pop	edx
 0000019D  46				inc  esi

					; if( byteCount mod 16 == 0 ) call Crlf

 0000019E  66| BA 0000			mov  dx,0
 000001A2  66| 8B 45 FA			mov  ax,byteCount
 000001A6  66| BB 0010			mov  bx,16
 000001AA  66| F7 F3			div  bx
 000001AD  66| 83 FA 00			cmp  dx,0
 000001B1  75 05			jne  L3B
 000001B3  E8 FFFFFF2D			call	Crlf
 000001B8			L3B:
 000001B8  E2 CC			Loop L3
 000001BA  EB 00			jmp  L4

 000001BC			L4:
 000001BC  E8 FFFFFF24			call	Crlf
 000001C1  61				popad
					ret
 000001C4			DumpMem ENDP


				;---------------------------------------------------
 000001C4			DumpRegs PROC
				;
				; Displays EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP in
				; hexadecimal. Also displays the Zero, Sign, Carry, and
				; Overflow flags.
				; Receives: nothing.
				; Returns: nothing.
				; Last update: 6/22/2005
				;
				; Warning: do not create any local variables or stack
				; parameters, because they will alter the EBP register.
				;---------------------------------------------------
 0000065D			.data
 0000065D 00000000		saveIP  DWORD ?
 00000661 00000000		saveESP DWORD ?
 000001C4			.code
 000001C4  8F 05 0000065D R		pop saveIP	; get current EIP
 000001CA  89 25 00000661 R		mov saveESP,esp	; save ESP's value at entry
 000001D0  FF 35 0000065D R		push saveIP	; replace it on stack
 000001D6  50				push eax	; save EAX (restore on exit)

 000001D7  9C				pushfd	; push extended flags

 000001D8  9C				pushfd	; push flags again, and
 000001D9  8F 05 0000000C R		pop  eflags	; save them in a variable

 000001DF  E8 FFFFFF01			call	Crlf
					mShowRegister EAX,EAX
 00000665		     1	.data
 00000665 20 20 45 41 58     1	??0006 BYTE "  EAX=",0
	   3D 00
 000001E4		     1	.code
 000001E4  50		     1		push eax
 000001E5  52		     1		push	edx
 000001E6  BA 00000665 R     1		mov	edx,OFFSET ??0006
 000001EB  E8 00000D0C	     1		call	WriteString
 000001F0  5A		     1		pop	edx
 000001F1  8B C0	     1		mov	eax,EAX
 000001F3  E8 00000A6A	     1		call	WriteHex
 000001F8  58		     1		pop	eax
					mShowRegister EBX,EBX
 0000066C		     1	.data
 0000066C 20 20 45 42 58     1	??0007 BYTE "  EBX=",0
	   3D 00
 000001F9		     1	.code
 000001F9  50		     1		push eax
 000001FA  52		     1		push	edx
 000001FB  BA 0000066C R     1		mov	edx,OFFSET ??0007
 00000200  E8 00000CF7	     1		call	WriteString
 00000205  5A		     1		pop	edx
 00000206  8B C3	     1		mov	eax,EBX
 00000208  E8 00000A55	     1		call	WriteHex
 0000020D  58		     1		pop	eax
					mShowRegister ECX,ECX
 00000673		     1	.data
 00000673 20 20 45 43 58     1	??0008 BYTE "  ECX=",0
	   3D 00
 0000020E		     1	.code
 0000020E  50		     1		push eax
 0000020F  52		     1		push	edx
 00000210  BA 00000673 R     1		mov	edx,OFFSET ??0008
 00000215  E8 00000CE2	     1		call	WriteString
 0000021A  5A		     1		pop	edx
 0000021B  8B C1	     1		mov	eax,ECX
 0000021D  E8 00000A40	     1		call	WriteHex
 00000222  58		     1		pop	eax
					mShowRegister EDX,EDX
 0000067A		     1	.data
 0000067A 20 20 45 44 58     1	??0009 BYTE "  EDX=",0
	   3D 00
 00000223		     1	.code
 00000223  50		     1		push eax
 00000224  52		     1		push	edx
 00000225  BA 0000067A R     1		mov	edx,OFFSET ??0009
 0000022A  E8 00000CCD	     1		call	WriteString
 0000022F  5A		     1		pop	edx
 00000230  8B C2	     1		mov	eax,EDX
 00000232  E8 00000A2B	     1		call	WriteHex
 00000237  58		     1		pop	eax
 00000238  E8 FFFFFEA8			call	Crlf
					mShowRegister ESI,ESI
 00000681		     1	.data
 00000681 20 20 45 53 49     1	??000A BYTE "  ESI=",0
	   3D 00
 0000023D		     1	.code
 0000023D  50		     1		push eax
 0000023E  52		     1		push	edx
 0000023F  BA 00000681 R     1		mov	edx,OFFSET ??000A
 00000244  E8 00000CB3	     1		call	WriteString
 00000249  5A		     1		pop	edx
 0000024A  8B C6	     1		mov	eax,ESI
 0000024C  E8 00000A11	     1		call	WriteHex
 00000251  58		     1		pop	eax
					mShowRegister EDI,EDI
 00000688		     1	.data
 00000688 20 20 45 44 49     1	??000B BYTE "  EDI=",0
	   3D 00
 00000252		     1	.code
 00000252  50		     1		push eax
 00000253  52		     1		push	edx
 00000254  BA 00000688 R     1		mov	edx,OFFSET ??000B
 00000259  E8 00000C9E	     1		call	WriteString
 0000025E  5A		     1		pop	edx
 0000025F  8B C7	     1		mov	eax,EDI
 00000261  E8 000009FC	     1		call	WriteHex
 00000266  58		     1		pop	eax

					mShowRegister EBP,EBP
 0000068F		     1	.data
 0000068F 20 20 45 42 50     1	??000C BYTE "  EBP=",0
	   3D 00
 00000267		     1	.code
 00000267  50		     1		push eax
 00000268  52		     1		push	edx
 00000269  BA 0000068F R     1		mov	edx,OFFSET ??000C
 0000026E  E8 00000C89	     1		call	WriteString
 00000273  5A		     1		pop	edx
 00000274  8B C5	     1		mov	eax,EBP
 00000276  E8 000009E7	     1		call	WriteHex
 0000027B  58		     1		pop	eax

 0000027C  A1 00000661 R		mov eax,saveESP
					mShowRegister ESP,EAX
 00000696		     1	.data
 00000696 20 20 45 53 50     1	??000D BYTE "  ESP=",0
	   3D 00
 00000281		     1	.code
 00000281  50		     1		push eax
 00000282  52		     1		push	edx
 00000283  BA 00000696 R     1		mov	edx,OFFSET ??000D
 00000288  E8 00000C6F	     1		call	WriteString
 0000028D  5A		     1		pop	edx
 0000028E  8B C0	     1		mov	eax,EAX
 00000290  E8 000009CD	     1		call	WriteHex
 00000295  58		     1		pop	eax
 00000296  E8 FFFFFE4A			call	Crlf

 0000029B  A1 0000065D R		mov eax,saveIP
					mShowRegister EIP,EAX
 0000069D		     1	.data
 0000069D 20 20 45 49 50     1	??000E BYTE "  EIP=",0
	   3D 00
 000002A0		     1	.code
 000002A0  50		     1		push eax
 000002A1  52		     1		push	edx
 000002A2  BA 0000069D R     1		mov	edx,OFFSET ??000E
 000002A7  E8 00000C50	     1		call	WriteString
 000002AC  5A		     1		pop	edx
 000002AD  8B C0	     1		mov	eax,EAX
 000002AF  E8 000009AE	     1		call	WriteHex
 000002B4  58		     1		pop	eax
 000002B5  A1 0000000C R		mov eax,eflags
					mShowRegister EFL,EAX
 000006A4		     1	.data
 000006A4 20 20 45 46 4C     1	??000F BYTE "  EFL=",0
	   3D 00
 000002BA		     1	.code
 000002BA  50		     1		push eax
 000002BB  52		     1		push	edx
 000002BC  BA 000006A4 R     1		mov	edx,OFFSET ??000F
 000002C1  E8 00000C36	     1		call	WriteString
 000002C6  5A		     1		pop	edx
 000002C7  8B C0	     1		mov	eax,EAX
 000002C9  E8 00000994	     1		call	WriteHex
 000002CE  58		     1		pop	eax

				; Show the flags (using the eflags variable). The integer parameter indicates
				; how many times EFLAGS must be shifted right to shift the selected flag 
				; into the Carry flag.

					ShowFlag CF,1
 000006AB		     1	.data
 000006AB 20 20 43 46 3D     1	??0010 DB "  CF="
 000006B0 00 00		     1	??0011 DB ?,0
 000002CF		     1	.code
 000002CF  50		     1		push eax
 000002D0  52		     1		push edx
 000002D1  A1 0000000C R     1		mov  eax,eflags	; retrieve the flags
 000002D6  C6 05 000006B0 R  1		mov  ??0011,'1'
	   31
 000002DD  D1 E8	     1		shr  eax,1	; shift into carry flag
 000002DF  72 07	     1		jc   ??0012
 000002E1  C6 05 000006B0 R  1		mov  ??0011,'0'
	   30
 000002E8		     1	??0012:
 000002E8  BA 000006AB R     1		mov  edx,OFFSET ??0010	; display flag name and value
 000002ED  E8 00000C0A	     1		call WriteString
 000002F2  5A		     1		pop  edx
 000002F3  58		     1		pop  eax
					ShowFlag SF,8
 000006B2		     1	.data
 000006B2 20 20 53 46 3D     1	??0013 DB "  SF="
 000006B7 00 00		     1	??0014 DB ?,0
 000002F4		     1	.code
 000002F4  50		     1		push eax
 000002F5  52		     1		push edx
 000002F6  A1 0000000C R     1		mov  eax,eflags	; retrieve the flags
 000002FB  C6 05 000006B7 R  1		mov  ??0014,'1'
	   31
 00000302  C1 E8 08	     1		shr  eax,8	; shift into carry flag
 00000305  72 07	     1		jc   ??0015
 00000307  C6 05 000006B7 R  1		mov  ??0014,'0'
	   30
 0000030E		     1	??0015:
 0000030E  BA 000006B2 R     1		mov  edx,OFFSET ??0013	; display flag name and value
 00000313  E8 00000BE4	     1		call WriteString
 00000318  5A		     1		pop  edx
 00000319  58		     1		pop  eax
					ShowFlag ZF,7
 000006B9		     1	.data
 000006B9 20 20 5A 46 3D     1	??0016 DB "  ZF="
 000006BE 00 00		     1	??0017 DB ?,0
 0000031A		     1	.code
 0000031A  50		     1		push eax
 0000031B  52		     1		push edx
 0000031C  A1 0000000C R     1		mov  eax,eflags	; retrieve the flags
 00000321  C6 05 000006BE R  1		mov  ??0017,'1'
	   31
 00000328  C1 E8 07	     1		shr  eax,7	; shift into carry flag
 0000032B  72 07	     1		jc   ??0018
 0000032D  C6 05 000006BE R  1		mov  ??0017,'0'
	   30
 00000334		     1	??0018:
 00000334  BA 000006B9 R     1		mov  edx,OFFSET ??0016	; display flag name and value
 00000339  E8 00000BBE	     1		call WriteString
 0000033E  5A		     1		pop  edx
 0000033F  58		     1		pop  eax
					ShowFlag OF,12
 000006C0		     1	.data
 000006C0 20 20 4F 46 3D     1	??0019 DB "  OF="
 000006C5 00 00		     1	??001A DB ?,0
 00000340		     1	.code
 00000340  50		     1		push eax
 00000341  52		     1		push edx
 00000342  A1 0000000C R     1		mov  eax,eflags	; retrieve the flags
 00000347  C6 05 000006C5 R  1		mov  ??001A,'1'
	   31
 0000034E  C1 E8 0C	     1		shr  eax,12	; shift into carry flag
 00000351  72 07	     1		jc   ??001B
 00000353  C6 05 000006C5 R  1		mov  ??001A,'0'
	   30
 0000035A		     1	??001B:
 0000035A  BA 000006C0 R     1		mov  edx,OFFSET ??0019	; display flag name and value
 0000035F  E8 00000B98	     1		call WriteString
 00000364  5A		     1		pop  edx
 00000365  58		     1		pop  eax
					ShowFlag AF,5
 000006C7		     1	.data
 000006C7 20 20 41 46 3D     1	??001C DB "  AF="
 000006CC 00 00		     1	??001D DB ?,0
 00000366		     1	.code
 00000366  50		     1		push eax
 00000367  52		     1		push edx
 00000368  A1 0000000C R     1		mov  eax,eflags	; retrieve the flags
 0000036D  C6 05 000006CC R  1		mov  ??001D,'1'
	   31
 00000374  C1 E8 05	     1		shr  eax,5	; shift into carry flag
 00000377  72 07	     1		jc   ??001E
 00000379  C6 05 000006CC R  1		mov  ??001D,'0'
	   30
 00000380		     1	??001E:
 00000380  BA 000006C7 R     1		mov  edx,OFFSET ??001C	; display flag name and value
 00000385  E8 00000B72	     1		call WriteString
 0000038A  5A		     1		pop  edx
 0000038B  58		     1		pop  eax
					ShowFlag PF,3
 000006CE		     1	.data
 000006CE 20 20 50 46 3D     1	??001F DB "  PF="
 000006D3 00 00		     1	??0020 DB ?,0
 0000038C		     1	.code
 0000038C  50		     1		push eax
 0000038D  52		     1		push edx
 0000038E  A1 0000000C R     1		mov  eax,eflags	; retrieve the flags
 00000393  C6 05 000006D3 R  1		mov  ??0020,'1'
	   31
 0000039A  C1 E8 03	     1		shr  eax,3	; shift into carry flag
 0000039D  72 07	     1		jc   ??0021
 0000039F  C6 05 000006D3 R  1		mov  ??0020,'0'
	   30
 000003A6		     1	??0021:
 000003A6  BA 000006CE R     1		mov  edx,OFFSET ??001F	; display flag name and value
 000003AB  E8 00000B4C	     1		call WriteString
 000003B0  5A		     1		pop  edx
 000003B1  58		     1		pop  eax

 000003B2  E8 FFFFFD2E			call	Crlf
 000003B7  E8 FFFFFD29			call	Crlf

 000003BC  9D				popfd
 000003BD  58				pop eax
 000003BE  C3				ret
 000003BF			DumpRegs ENDP


				;-------------------------------------------------------------
 000003BF			GetCommandTail PROC
				;
				; Copies the tail of the program command line into a buffer
				; (after stripping off the first argument - the program's name)
				; Receives: EDX points to a 129-byte buffer that will receive
				; the data.
				; Returns: Carry Flag = 1 if no command tail, otherwise CF=0
				;
				; Calls the WIN API function GetCommandLine, and scan_for_quote,
				; a private helper procedure. Each argument in the command line tail 
				; is followed by a space except for the last argument which is 
				; followed only by null.
				;
				; Implementation notes:
				;
				; Running in a console window:
				; When the command line is blank, GetCommandLine under Windows 95/98
				; returns the program name followed by a space and a null. Windows 2000/XP
				; returns the program name followed by only null (the space is omitted). 
				;
				; Running from an IDE such as TextPad or JCreator:
				; When the command line is blank, GetCommandLine returns the program 
				; name followed by a space and a null for all versions of Windows.
				;
				; Contributed by Gerald Cahill, 9/26/2002
				; Modified by Kip Irvine, 6/13/2005.
				;-------------------------------------------------------------

 = 00000022			QUOTE_MARK = 22h

 000003BF  60				pushad
					INVOKE GetCommandLine   	; returns pointer in EAX

				; Initialize first byte of user's buffer to null, in case the 
				; buffer already contains text.

 000003C5  C6 02 00			mov	BYTE PTR [edx],0

				; Copy the command-line string to the array. Read past the program's 
				; EXE filename (may include the path). This code will not work correctly 
				; if the path contains an embedded space.

 000003C8  8B F0			mov	esi,eax
 000003CA  8A 06		L0:	mov	al,[esi]    	; strip off first argument
 000003CC  46				inc	esi
					.IF al == QUOTE_MARK	; quotation mark found?
 000003D1  E8 0000001E			call	scan_for_quote	; scan until next quote mark
 000003D6  EB 0A			jmp	LB	; and get the rest of the line
					.ENDIF
 000003D8  3C 20			cmp	al,' '      	; look for blank
 000003DA  74 06			je 	LB	; found it
 000003DC  3C 01			cmp	al,1	; look for null
 000003DE  72 12			jc	L2	; found it (set CF=1)
 000003E0  EB E8			jmp	L0	; not found yet

				; Check if the rest of the tail is empty.

 000003E2  80 3E 01		LB:	cmp	BYTE PTR [esi],1	; first byte in tail < 1?
 000003E5  72 0B			jc	L2	; the tail is empty (CF=1)

				; Copy all bytes from the command tail to the buffer.

 000003E7  8A 06		L1:	mov	al,[esi]	; get byte from cmd tail
 000003E9  88 02			mov	[edx],al	; copy to buffer
 000003EB  46				inc	esi
 000003EC  42				inc	edx
 000003ED  3C 00			cmp	al,0      	; null byte found?
 000003EF  75 F6			jne	L1          	; no, loop
					
 000003F1  F8				clc		; CF=0 means a tail was found

 000003F2  61			L2:	popad
 000003F3  C3				ret
 000003F4			GetCommandTail ENDP


				;------------------------------------------------------------
 000003F4			scan_for_quote PROC PRIVATE
				;
				; Helper procedure that looks for a closing quotation mark. This 
				; procedure lets us handle path names with embedded spaces.
				; Called by: GetCommandTail
				;
				; Receives: ESI points to the current position in the command tail.
				; Returns: ESI points one position beyond the quotation mark.
				;------------------------------------------------------------

 000003F4  8A 06		L0:	mov	al,[esi]    	; get a byte
 000003F6  46				inc	esi	; point beyond it
 000003F7  3C 22			cmp	al,QUOTE_MARK	; quotation mark found?
 000003F9  75 F9			jne	L0	; not found yet

 000003FB  C3				ret 
 000003FC			scan_for_quote ENDP


				;--------------------------------------------------
 000003FC			GetDateTime PROC,
					pDateTime:PTR QWORD
					LOCAL flTime:FILETIME
				;
				; Gets the current local date and time, storing it as a
				; 64-bit integer (Win32 FILETIME format) in memory at 
				; the address specified by the input parameter.
				; Receives: pointer to a QWORD variable (inout parameter)
				; Returns: nothing
				; Updated 10/20/2002
				;--------------------------------------------------
 00000402  60				pushad

				; Get the system local time.
					INVOKE GetLocalTime,
					  ADDR sysTime

				; Convert the SYSTEMTIME to FILETIME.
					INVOKE SystemTimeToFileTime,
					  ADDR sysTime,
					  ADDR flTime

				; Copy the FILETIME to a Quadword.
 0000041B  8B 75 08			mov esi,pDateTime
 0000041E  8B 45 F8			mov eax,flTime.loDateTime
 00000421  89 06			mov DWORD PTR [esi],eax
 00000423  8B 45 FC			mov eax,flTime.hiDateTime
 00000426  89 46 04			mov DWORD PTR [esi+4],eax

 00000429  61				popad
					ret
 0000042E			GetDateTime ENDP


				;----------------------------------------------------------------
 0000042E			GetMaxXY PROC
					LOCAL bufInfo:CONSOLE_SCREEN_BUFFER_INFO
				;
				; Returns the current columns (X) and rows (Y) of the console
				; window buffer. These values can change while a program is running
				; if the user modifies the properties of the application window.
				; Receives: nothing
				; Returns: DH = rows (Y); DL = columns (X)
				; (range of each is 1-255)
				;
				; Added to the library on 10/20/2002, on the suggestion of Ben Schwartz.
				;----------------------------------------------------------------
 00000434  50				push eax
					CheckInit
 00000435  80 3D 00000000 R  1		cmp InitFlag,0
	   00
 0000043C  75 05	     1		jne ??0022
 0000043E  E8 000000DC	     1		call Initialize
 00000443		     1	??0022:

					; Get the console buffer size and attributes
 00000443  60				pushad
					INVOKE GetConsoleScreenBufferInfo, consoleOutHandle, ADDR bufInfo
 00000453  61				popad

 00000454  66| 8B 55 EA			mov dx,bufInfo.dwSize.X
 00000458  66| 8B 45 EC			mov ax,bufInfo.dwSize.Y
 0000045C  8A F0			mov dh,al

 0000045E  58				pop eax
					ret
 00000461			GetMaxXY ENDP


				;----------------------------------------------------------------
 00000461			GetMseconds PROC USES ebx edx
					LOCAL hours:DWORD, min:DWORD, sec:DWORD
				;
				Comment !
				Returns the number of milliseconds that have elapsed past midnight.
				Receives: nothing; Returns: milliseconds
				Implementation Notes:
				Calculation: ((hours * 3600) + (minutes * 60) + seconds)) * 1000 + milliseconds
				Under Win NT/ 2000/ XT, the resolution is 10ms.  Under Win 98/ ME/ or any
				DOS-based version, the resolution is 55ms (average).

				Last update: 1/30/03
				-----------------------------------------------------------------!
 00000469  60				pushad
					INVOKE GetLocalTime,OFFSET sysTime
					; convert hours to seconds
 00000474  61				popad
 00000475  0F B7 05			movzx eax,sysTime.wHour
	   0000026D R
 0000047C  BB 00000E10			mov   ebx,3600
 00000481  F7 E3			mul   ebx
 00000483  89 45 FC			mov   hours,eax

					; convert minutes to seconds
 00000486  0F B7 05			movzx eax,sysTime.wMinute
	   0000026F R
 0000048D  BB 0000003C			mov   ebx,60
 00000492  F7 E3			mul   ebx
 00000494  89 45 F8			mov   min,eax

					; add seconds to total seconds
 00000497  0F B7 05			movzx eax,sysTime.wSecond
	   00000271 R
 0000049E  89 45 F4			mov  sec,eax

					; multiply seconds by 1000
 000004A1  8B 45 FC			mov  eax,hours
 000004A4  03 45 F8			add  eax,min
 000004A7  03 45 F4			add  eax,sec
 000004AA  BB 000003E8			mov  ebx,1000
 000004AF  F7 E3			mul  ebx

					; add milliseconds to total
 000004B1  0F B7 1D			movzx ebx,sysTime.wMilliseconds
	   00000273 R
 000004B8  03 C3			add  eax,ebx

					ret
 000004BE			GetMseconds ENDP


				;--------------------------------------------------
 000004BE			GetTextColor PROC
					LOCAL bufInfo:CONSOLE_SCREEN_BUFFER_INFO
				;
				;
				; Get the console window's color attributes. 
				; Receives: nothing
				; Returns: AH = background color, AL = foreground 
				;   color 
				;--------------------------------------------------

 000004C4  60				pushad
					CheckInit
 000004C5  80 3D 00000000 R  1		cmp InitFlag,0
	   00
 000004CC  75 05	     1		jne ??0023
 000004CE  E8 0000004C	     1		call Initialize
 000004D3		     1	??0023:

					; Get the console buffer size and attributes
					INVOKE GetConsoleScreenBufferInfo, consoleOutHandle, ADDR bufInfo
 000004E2  61				popad
					
 000004E3  66| 8B 45 F2			mov  ax,bufInfo.wAttributes
					ret
 000004E9			GetTextColor ENDP


				;--------------------------------------------------
 000004E9			Gotoxy PROC
				;
				; Locate the cursor
				; Receives: DH = screen row, DL = screen column
				; Last update: 7/11/01
				;--------------------------------------------------------
 000006D5			.data
 000006D5 0000 0000		_cursorPosition COORD <>
 000004E9			.code
 000004E9  60				pushad

					CheckInit	; was console initialized?
 000004EA  80 3D 00000000 R  1		cmp InitFlag,0
	   00
 000004F1  75 05	     1		jne ??0024
 000004F3  E8 00000027	     1		call Initialize
 000004F8		     1	??0024:
 000004F8  66| 0F B6 C2			movzx ax,dl
 000004FC  66| A3			mov _cursorPosition.X, ax
	   000006D5 R
 00000502  66| 0F B6 C6			movzx ax,dh
 00000506  66| A3			mov _cursorPosition.Y, ax
	   000006D7 R
					INVOKE SetConsoleCursorPosition, consoleOutHandle, _cursorPosition

 0000051D  61				popad
 0000051E  C3				ret
 0000051F			Gotoxy ENDP


				;----------------------------------------------------
 0000051F			Initialize PROC private
				;
				; Get the standard console handles for input and output,
				; and set a flag indicating that it has been done.
				; Updated 03/17/2003
				;----------------------------------------------------
 0000051F  60				pushad

					INVOKE GetStdHandle, STD_INPUT_HANDLE
 00000527  A3 00000000 R		mov [consoleInHandle],eax

					INVOKE GetStdHandle, STD_OUTPUT_HANDLE
 00000533  A3 00000004 R		mov [consoleOutHandle],eax

 00000538  C6 05 00000000 R		mov InitFlag,1
	   01

 0000053F  61				popad
 00000540  C3				ret
 00000541			Initialize ENDP


				;-----------------------------------------------
 00000541			IsDigit PROC
				;
				; Determines whether the character in AL is a
				; valid decimal digit.
				; Receives: AL = character
				; Returns: ZF=1 if AL contains a valid decimal
				;   digit; otherwise, ZF=0.
				;-----------------------------------------------
 00000541  3C 30			 cmp   al,'0'
 00000543  72 08			 jb    ID1
 00000545  3C 39			 cmp   al,'9'
 00000547  77 04			 ja    ID1
 00000549  66| A9 0000			 test  ax,0     		; set ZF = 1
 0000054D  C3			ID1: ret
 0000054E			IsDigit ENDP


				;-----------------------------------------------
 0000054E			MsgBox PROC
				;
				; Displays a popup message box.
				; Receives: EDX = offset of message, EBX = 
				; 	offset of caption (or 0 if no caption)
				; Returns: nothing
				;-----------------------------------------------
 000006D9			.data
 000006D9 20 00			@zx02abc_def_caption BYTE " ",0
 0000054E			.code
 0000054E  60				pushad
					
					.IF ebx == 0
 00000553  BB 000006D9 R		  mov  ebx,OFFSET @zx02abc_def_caption
					.ENDIF
					INVOKE MessageBox, 0, edx, ebx, 0 

 00000563  61				popad
 00000564  C3				ret
 00000565			MsgBox ENDP


				;--------------------------------------------------
 00000565			MsgBoxAsk PROC uses ebx ecx edx esi edi
				;
				; Displays a message box with a question icon and 
				;    Yes/No buttons.
				; Receives: EDX = offset of message. For a blank
				;   caption, set EBX to NULL; otherwise, EBX = offset 
				;   of the caption string.
				; Returns: EAX equals IDYES (6) or IDNO (7).
				;--------------------------------------------------
 000006DB			.data
 000006DB 20 00			@zq02abc_def_caption BYTE " ",0
 0000056A			.code
					.IF ebx == NULL
 0000056E  BB 000006DB R		  mov  ebx,OFFSET @zq02abc_def_caption
					.ENDIF
					INVOKE MessageBox, NULL, edx, ebx, 
						MB_YESNO + MB_ICONQUESTION
						
					ret
 00000584			MsgBoxAsk ENDP


				;------------------------------------------------------
 00000584			OpenInputFile PROC
				;
				; Opens an existing file for input.
				; Receives: EDX points to the filename.
				; Returns: If the file was opened successfully, EAX 
				; contains a valid file handle. Otherwise, EAX equals 
				; INVALID_HANDLE_VALUE.
				; Last update: 6/8/2005
				;------------------------------------------------------

					INVOKE CreateFile,
					  edx, GENERIC_READ, DO_NOT_SHARE, NULL,
					  OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0
 0000059C  C3				ret
 0000059D			OpenInputFile ENDP


				;--------------------------------------------------------
 0000059D			ParseDecimal32 PROC USES ebx ecx edx esi
				  LOCAL saveDigit:DWORD
				;
				; Converts (parses) a string containing an unsigned decimal
				; integer, and converts it to binary. All valid digits occurring 
				; before a non-numeric character are converted. 
				; Leading spaces are ignored.

				; Receives: EDX = offset of string, ECX = length 
				; Returns:
				;  If the integer is blank, EAX=0 and CF=1
				;  If the integer contains only spaces, EAX=0 and CF=1
				;  If the integer is larger than 2^32-1, EAX=0 and CF=1
				;  Otherwise, EAX=converted integer, and CF=0
				;
				; Created 7/15/05 (from the old ReadDec procedure)
				;--------------------------------------------------------

 000005A7  8B F2			mov   esi,edx           		; save offset in ESI

 000005A9  83 F9 00			cmp   ecx,0            		; length greater than zero?
 000005AC  75 07			jne   L1              		; yes: continue
 000005AE  B8 00000000			mov   eax,0            		; no: set return value
 000005B3  EB 3E			jmp   L5              		; and exit with CF=1

				; Skip over leading spaces, tabs

 000005B5  8A 06		L1:	mov   al,[esi]         		; get a character from buffer
 000005B7  3C 20			cmp   al,' '        		; space character found?
 000005B9  74 06			je	L1A		; yes: skip it
 000005BB  3C 09			cmp	al,TAB		; TAB found?
 000005BD  74 02			je	L1A		; yes: skip it
 000005BF  EB 05			jmp   L2              		; no: goto next step
					
 000005C1			L1A:
 000005C1  46				inc   esi              		; yes: point to next char
 000005C2  E2 F1			loop  L1		; continue searching until end of string
 000005C4  EB 2D			jmp   L5		; exit with CF=1 if all spaces

				; Replaced code (7/19/05)---------------------------------------------
				;L1:mov   al,[esi]         		; get a character from buffer
				;	cmp   al,' '          		; space character found?
				;	jne   L2              		; no: goto next step
				;	inc   esi              		; yes: point to next char
				;	loop  L1		; all spaces?
				;	jmp   L5		; yes: exit with CF=1
				;---------------------------------------------------------------------

				; Start to convert the number.

 000005C6  B8 00000000		L2:	mov  eax,0           		; clear accumulator
 000005CB  BB 0000000A			mov  ebx,10          		; EBX is the divisor

				; Repeat loop for each digit.

 000005D0  8A 16		L3:	mov  dl,[esi]		; get character from buffer
 000005D2  80 FA 30			cmp  dl,'0'		; character < '0'?
 000005D5  72 19			jb   L4
 000005D7  80 FA 39			cmp  dl,'9'		; character > '9'?
 000005DA  77 14			ja   L4
 000005DC  83 E2 0F			and  edx,0Fh		; no: convert to binary

 000005DF  89 55 FC			mov  saveDigit,edx
 000005E2  F7 E3			mul  ebx		; EDX:EAX = EAX * EBX
 000005E4  72 0D			jc   L5		; quit if Carry (EDX > 0)
 000005E6  8B 55 FC			mov  edx,saveDigit
 000005E9  03 C2			add  eax,edx         		; add new digit to sum
 000005EB  72 06			jc   L5		; quit if Carry generated
 000005ED  46				inc  esi              		; point to next digit
 000005EE  EB E0			jmp  L3		; get next digit

 000005F0  F8			L4:	clc			; succesful completion (CF=0)
 000005F1  EB 06			jmp  L6

 000005F3  B8 00000000		L5:	mov  eax,0		; clear result to zero
 000005F8  F9				stc			; signal an error (CF=1)

 000005F9			L6:	ret
 000005FF			ParseDecimal32 ENDP


				;--------------------------------------------------------
 000005FF			ParseInteger32 PROC USES ebx ecx edx esi
				  LOCAL Lsign:SDWORD, saveDigit:DWORD
				;
				; Converts a string containing a signed decimal integer to
				; binary. 
				;
				; All valid digits occurring before a non-numeric character
				; are converted. Leading spaces are ignored, and an optional 
				; leading + or - sign is permitted. If the string is blank, 
				; a value of zero is returned.
				;
				; Receives: EDX = string offset, ECX = string length
				; Returns:  If CF=0, the integer is valid, and EAX = binary value.
				;   If CF=1, the integer is invalid and EAX = 0.
				;
				; Created 7/15/05, using Gerald Cahill's 10/10/03 corrections.
				; Updated 7/19/05, to skip over tabs
				;--------------------------------------------------------
 000006DD			.data
 000006DD 20 3C 33 32 2D	overflow_msgL BYTE  " <32-bit integer overflow>",0
	   62 69 74 20 69
	   6E 74 65 67 65
	   72 20 6F 76 65
	   72 66 6C 6F 77
	   3E 00
 000006F8 20 3C 69 6E 76	invalid_msgL  BYTE  " <invalid integer>",0
	   61 6C 69 64 20
	   69 6E 74 65 67
	   65 72 3E 00
 00000609			.code

 00000609  C7 45 FC			mov   Lsign,1                   ; assume number is positive
	   00000001
 00000610  8B F2			mov   esi,edx                   ; save offset in SI

 00000612  83 F9 00			cmp   ecx,0                     ; length greater than zero?
 00000615  75 0A			jne   L1                        ; yes: continue
 00000617  B8 00000000			mov   eax,0                     ; no: set return value
 0000061C  E9 00000093			jmp   L10                       ; and exit

				; Skip over leading spaces and tabs.

 00000621  8A 06		L1:	mov   al,[esi]         		; get a character from buffer
 00000623  3C 20			cmp   al,' '        		; space character found?
 00000625  74 06			je	L1A		; yes: skip it
 00000627  3C 09			cmp	al,TAB		; TAB found?
 00000629  74 02			je	L1A		; yes: skip it
 0000062B  EB 0A			jmp   L2              		; no: goto next step
					
 0000062D			L1A:
 0000062D  46				inc   esi              		; yes: point to next char
 0000062E  E2 F1			loop  L1		; continue searching until end of string
 00000630  B8 00000000			mov	eax,0		; all spaces?
 00000635  EB 7D			jmp   L10		; return 0 as a valid value

				;-- Replaced code (7/19/05)---------------------------------------
				;L1:	mov   al,[esi]                  ; get a character from buffer
				;	cmp   al,' '                    ; space character found?
				;	jne   L2                        ; no: check for a sign
				;	inc   esi                       ; yes: point to next char
				;	loop  L1
				;	mov   eax,0	  ; all spaces?
				;	jmp   L10	  ; return zero as valid value
				;------------------------------------------------------------------

				; Check for a leading sign.

 00000637  3C 2D		L2:	cmp   al,'-'                    ; minus sign found?
 00000639  75 0B			jne   L3                        ; no: look for plus sign

 0000063B  C7 45 FC			mov   Lsign,-1                  ; yes: sign is negative
	   FFFFFFFF
 00000642  49				dec   ecx                       ; subtract from counter
 00000643  46				inc   esi                       ; point to next char
 00000644  EB 06			jmp   L3A

 00000646  3C 2B		L3:	cmp   al,'+'                    ; plus sign found?
 00000648  75 02			jne   L3A               			; no: skip
 0000064A  46				inc   esi                       ; yes: move past the sign
 0000064B  49				dec   ecx                       ; subtract from digit counter

				; Test the first digit, and exit if nonnumeric.

 0000064C  8A 06		L3A: mov  al,[esi]          	; get first character
 0000064E  E8 FFFFFEEE			call IsDigit            	; is it a digit?
 00000653  75 40			jnz  L7A                	; no: show error message

				; Start to convert the number.

 00000655  B8 00000000		L4:	mov   eax,0                  	; clear accumulator
 0000065A  BB 0000000A			mov   ebx,10                  ; EBX is the divisor

				; Repeat loop for each digit.

 0000065F  8A 16		L5:	mov  dl,[esi]           	; get character from buffer
 00000661  80 FA 30			cmp  dl,'0'             	; character < '0'?
 00000664  72 49			jb   L9
 00000666  80 FA 39			cmp  dl,'9'             	; character > '9'?
 00000669  77 44			ja   L9
 0000066B  83 E2 0F			and  edx,0Fh            	; no: convert to binary

 0000066E  89 55 F8			mov  saveDigit,edx
 00000671  F7 EB			imul ebx               	; EDX:EAX = EAX * EBX
 00000673  8B 55 F8			mov  edx,saveDigit

 00000676  70 07			jo   L6                	; quit if overflow
 00000678  03 C2			add  eax,edx            	; add new digit to AX
 0000067A  70 03			jo   L6                 	; quit if overflow
 0000067C  46				inc  esi                	; point to next digit
 0000067D  EB E0			jmp  L5                 	; get next digit

				; Overflow has occured, unlesss EAX = 80000000h
				; and the sign is negative:

 0000067F  3D 80000000		L6:	cmp  eax,80000000h
 00000684  75 08			jne  L7
 00000686  83 7D FC FF			cmp  Lsign,-1
 0000068A  75 02		    jne  L7                 	; overflow occurred
 0000068C  EB 21		    jmp  L9                 	; the integer is valid

				; Choose "integer overflow" messsage.

 0000068E  BA 000006DD R	L7: mov  edx,OFFSET overflow_msgL
 00000693  EB 05		    jmp  L8

				; Choose "invalid integer" message.

 00000695			L7A:
 00000695  BA 000006F8 R	    mov  edx,OFFSET invalid_msgL

				; Display the error message pointed to by EDX, and set the Overflow flag.

 0000069A  E8 0000085D		L8:	call WriteString
 0000069F  E8 FFFFFA41		    call Crlf
 000006A4  B0 7F		    mov al,127
 000006A6  04 01		    add al,1                	; set Overflow flag
 000006A8  B8 00000000		    mov  eax,0              	; set return value to zero
 000006AD  EB 05		    jmp  L10                	; and exit

				; IMUL leaves the Sign flag in an undeterminate state, so the OR instruction
				; determines the sign of the iteger in EAX.
 000006AF  F7 6D FC		L9:	imul Lsign                  	; EAX = EAX * sign
 000006B2  0B C0		    or eax,eax              	; determine the number's Sign

 000006B4			L10:ret
 000006BA			ParseInteger32 ENDP


				;--------------------------------------------------------------
 000006BA			Random32  PROC
				;
				; Generates an unsigned pseudo-random 32-bit integer
				;   in the range 0 - FFFFFFFFh.
				; Receives: nothing
				; Returns: EAX = random integer
				; Last update: 7/11/01
				;--------------------------------------------------------------
 0000070B			.data
 0000070B 00000001		seed  DWORD 1
 000006BA			.code
 000006BA  52				  push  edx
 000006BB  B8 000343FD			  mov   eax, 343FDh
 000006C0  F7 2D 0000070B R		  imul  seed
 000006C6  05 00269EC3			  add   eax, 269EC3h
 000006CB  A3 0000070B R		  mov   seed, eax    ; save the seed for the next call
 000006D0  C1 C8 08			  ror   eax,8        ; rotate out the lowest digit (10/22/00)
 000006D3  5A				  pop   edx

 000006D4  C3				  ret
 000006D5			Random32  ENDP


				;--------------------------------------------------------------
 000006D5			RandomRange PROC
				;
				; Returns an unsigned pseudo-random 32-bit integer
				; in EAX, between 0 and n-1. Input parameter:
				; EAX = n.
				; Last update: 09/06/2002
				;--------------------------------------------------------------
 000006D5  53				 push  ebx
 000006D6  52				 push  edx

 000006D7  8B D8			 mov   ebx,eax  ; maximum value
 000006D9  E8 FFFFFFDC			 call  Random32 ; eax = random number
 000006DE  BA 00000000			 mov   edx,0
 000006E3  F7 F3			 div   ebx      ; divide by max value
 000006E5  8B C2			 mov   eax,edx  ; return the remainder

 000006E7  5A				 pop   edx
 000006E8  5B				 pop   ebx

 000006E9  C3				 ret
 000006EA			RandomRange ENDP


				;--------------------------------------------------------
 000006EA			Randomize PROC
				;
				; Re-seeds the random number generator with the current time
				; in seconds.
				; Receives: nothing
				; Returns: nothing
				; Last update: 09/06/2002
				;--------------------------------------------------------
 000006EA  60				  pushad

					  INVOKE GetSystemTime,OFFSET sysTime
 000006F5  0F B7 05			  movzx eax,sysTime.wMilliseconds
	   00000273 R
 000006FC  A3 0000070B R		  mov   seed,eax

 00000701  61				  popad
 00000702  C3				  ret
 00000703			Randomize ENDP


				;------------------------------------------------------------
 00000703			ReadChar PROC USES ebx edx
				;
				; Reads one character from the keyboard. The character is
				; not echoed on the screen. Waits for the character if none is
				; currently in the input buffer.
				; Returns:  AL = ASCII code, AH = scan code
				; Last update: 7/6/05
				;----------------------------------------------------------

 00000705  B8 0000000A		L1:	mov  eax,10	; give Windows 10ms to process messages
 0000070A  E8 FFFFF9F1			call Delay
 0000070F  E8 000000DF			call ReadKey	; look for key in buffer
 00000714  74 EF			jz   L1	; no key in buffer if ZF=1

					ret
 00000719			ReadChar ENDP


				;--------------------------------------------------------
 00000719			ReadDec PROC USES ecx edx
				;
				; Reads a 32-bit unsigned decimal integer from the keyboard,
				; stopping when the Enter key is pressed.All valid digits occurring 
				; before a non-numeric character are converted to the integer value. 
				; Leading spaces are ignored.

				; Receives: nothing
				; Returns:
				;  If the integer is blank, EAX=0 and CF=1
				;  If the integer contains only spaces, EAX=0 and CF=1
				;  If the integer is larger than 2^32-1, EAX=0 and CF=1
				;  Otherwise, EAX=converted integer, and CF=0
				;
				; Last update: 7/15/05
				;--------------------------------------------------------

 0000071B  BA 00000010 R		mov   edx,OFFSET digitBuffer
 00000720  B9 00000050			mov	ecx,MAX_DIGITS
 00000725  E8 000002B2			call  ReadString
 0000072A  8B C8			mov	ecx,eax	; save length

 0000072C  E8 FFFFFE6C			call	ParseDecimal32	; returns EAX

					ret
 00000734			ReadDec ENDP


				;--------------------------------------------------------
 00000734			ReadFromFile PROC
				;
				; Reads an input file into a buffer. 
				; Receives: EAX = file handle, EDX = buffer offset,
				;    ECX = number of bytes to read
				; Returns: If CF = 0, EAX = number of bytes read; if
				;    CF = 1, EAX contains the system error code returned
				;    by the GetLastError Win32 API function.
				; Last update: 7/6/2005
				;--------------------------------------------------------

					INVOKE ReadFile,
					    eax,	; file handle
					    edx,	; buffer pointer
					    ecx,	; max bytes to read
					    ADDR bytesRead,	; number of bytes read
					    0		; overlapped execution flag
 00000743  83 F8 00			cmp	eax,0	; failed?
 00000746  75 08			jne	L1	; no: return bytesRead
					INVOKE GetLastError	; yes: EAX = error code
 0000074D  F9				stc		; set Carry flag
 0000074E  EB 06			jmp	L2
					    
 00000750  A1 00000261 R	L1:	mov	eax,bytesRead	; success
 00000755  F8				clc		; clear Carry flag
					
 00000756  C3			L2:	ret
 00000757			ReadFromFile ENDP


				;--------------------------------------------------------
 00000757			ReadHex PROC USES ebx ecx edx esi
				;
				; Reads a 32-bit hexadecimal integer from the keyboard,
				; stopping when the Enter key is pressed.
				; Receives: nothing
				; Returns: EAX = binary integer value
				; Returns:
				;  If the integer is blank, EAX=0 and CF=1
				;  If the integer contains only spaces, EAX=0 and CF=1
				;  Otherwise, EAX=converted integer, and CF=0

				; Remarks: No error checking performed for bad digits
				; or excess digits.
				; Last update: 7/19/05 (skip leading spaces and tabs)
				;--------------------------------------------------------
 0000070F			.data
 0000070F 00 01 02 03 04	xbtable     BYTE 0,1,2,3,4,5,6,7,8,9,7 DUP(0FFh),10,11,12,13,14,15
	   05 06 07 08 09
	   00000007 [
	    FF
	   ] 0A 0B 0C 0D
	   0E 0F
 00000726 00000000		numVal      DWORD ?
 0000072A 00			charVal     BYTE ?

 0000075B			.code
 0000075B  BA 00000010 R		mov   edx,OFFSET digitBuffer
 00000760  8B F2			mov   esi,edx		; save in ESI also
 00000762  B9 00000050			mov   ecx,MAX_DIGITS
 00000767  E8 00000270			call  ReadString		; input the string
 0000076C  8B C8			mov   ecx,eax           		; save length in ECX
 0000076E  83 F9 00			cmp   ecx,0            		; greater than zero?
 00000771  75 02			jne   B1              		; yes: continue
 00000773  EB 58			jmp   B8              		; no: exit with CF=1

				; Skip over leading spaces and tabs.

 00000775  8A 06		B1:	mov   al,[esi]         		; get a character from buffer
 00000777  3C 20			cmp   al,' '        		; space character found?
 00000779  74 06			je	B1A		; yes: skip it
 0000077B  3C 09			cmp	al,TAB		; TAB found?
 0000077D  74 02			je	B1A		; yes: skip it
 0000077F  EB 05			jmp   B4              		; no: goto next step
					
 00000781			B1A:
 00000781  46				inc   esi              		; yes: point to next char
 00000782  E2 F1			loop  B1		; all spaces?
 00000784  EB 47			jmp   B8		; yes: exit with CF=1

				;--- Replaced code (7/19/05)-------------------------------------
				;B1:	mov   al,[esi]         		; get a character from buffer
				;	cmp   al,' '          		; space character found?
				;	jne   B4              		; no: goto next step
				;	inc   esi              		; yes: point to next char
				;	loop  B1		; all spaces?
				;	jmp   B8		; yes: exit with CF=1
				;------------------------------------------------------------------

					; Start to convert the number.

 00000786  C7 05 00000726 R	B4: mov  numVal,0		; clear accumulator
	   00000000
 00000790  BB 0000070F R		mov  ebx,OFFSET xbtable		; translate table

					; Repeat loop for each digit.

 00000795  8A 06		B5: mov  al,[esi]	; get character from buffer
 00000797  3C 46			cmp  al,'F'	; lowercase letter?
 00000799  76 02			jbe  B6	; no
 0000079B  24 DF			and  al,11011111b	; yes: convert to uppercase

 0000079D  2C 30		B6:	sub  al,30h	; adjust for table
 0000079F  D7				xlat  	; translate to binary
 000007A0  A2 0000072A R		mov  charVal,al
 000007A5  B8 00000010			mov  eax,16	; numVal *= 16
 000007AA  F7 25 00000726 R		mul  numVal
 000007B0  A3 00000726 R		mov  numVal,eax
 000007B5  0F B6 05			movzx eax,charVal	; numVal += charVal
	   0000072A R
 000007BC  01 05 00000726 R		add  numVal,eax
 000007C2  46				inc  esi	; point to next digit
 000007C3  E2 D0			loop B5	; repeat, decrement counter

 000007C5  A1 00000726 R	B7:	mov  eax,numVal	; return valid value
 000007CA  F8				clc	; CF=0
 000007CB  EB 06			jmp  B9

 000007CD  B8 00000000		B8:	mov  eax,0	; error: return 0
 000007D2  F9				stc	; CF=1

 000007D3			B9:	ret
 000007D8			ReadHex ENDP


				;--------------------------------------------------------
 000007D8			ReadInt PROC USES ecx edx
				;
				; Reads a 32-bit signed decimal integer from standard
				; input, stopping when the Enter key is pressed.
				; All valid digits occurring before a non-numeric character
				; are converted to the integer value. Leading spaces are
				; ignored, and an optional leading + or - sign is permitted.
				; All spaces return a valid integer, value zero.

				; Receives: nothing
				; Returns:  If CF=0, the integer is valid, and EAX = binary value.
				;   If CF=1, the integer is invalid and EAX = 0.
				;
				; Updated: 7/15/05
				;--------------------------------------------------------

				; Input a signed decimal string.

 000007DA  BA 00000010 R		mov   edx,OFFSET digitBuffer
 000007DF  B9 00000050			mov   ecx,MAX_DIGITS
 000007E4  E8 000001F3			call  ReadString
 000007E9  8B C8			mov   ecx,eax	; save length in ECX

				; Convert to binary (EDX -> string, ECX = length)
					
 000007EB  E8 FFFFFE0F			call	ParseInteger32	; returns EAX, CF

					ret
 000007F3			ReadInt ENDP


				;------------------------------------------------------------------------------
 000007F3			ReadKey PROC USES ecx
					LOCAL evEvents:DWORD, saveFlags:DWORD
				;
				; Performs a no-wait keyboard check and single character read if available.
				; If Ascii is zero, special keys can be processed by checking scans and VKeys
				; Receives: nothing
				; Returns:  ZF is set if no keys are available, clear if we have read the key
				;	al  = key Ascii code (is set to zero for special extended codes)
				;	ah  = Keyboard scan code (as in inside cover of book)
				;	dx  = Virtual key code
				;	ebx = Keyboard flags (Alt,Ctrl,Caps,etc.)
				; Upper halves of EAX and EDX are overwritten
				;
				; ** Note: calling ReadKey prevents Ctrl-C from being used to terminate a program.
				;
				; Written by Richard Stam, used by permission.
				; Modified 4/6/03 by Irvine; modified 4/16/03 by Jerry Cahill
				; ; 6/21/05, Irvine: changed evEvents from WORD to DWORD
				;------------------------------------------------------------------------------
 0000072B			.data
 0000072B 0000 0000		evBuffer INPUT_RECORD <>	; Buffers our key "INPUT_RECORD"
	   00000000 0000
	   0000 0000 0000
	   00000000
 0000073F 0000			evRepeat WORD  0	; Controls key repeat counting

 000007FA			.code
					CheckInit	; call Inititialize, if not already called
 000007FA  80 3D 00000000 R  1		cmp InitFlag,0
	   00
 00000801  75 05	     1		jne ??0025
 00000803  E8 FFFFFD17	     1		call Initialize
 00000808		     1	??0025:

					; Save console flags
					INVOKE GetConsoleMode,consoleInHandle,ADDR saveFlags

					; Clear console flags, making it possible to detect Ctrl-C and Ctrl-S.
					INVOKE SetConsoleMode,consoleInHandle,0

 00000824  66| 83 3D			cmp evRepeat,0	; key already processed by previous call to this function?
	   0000073F R 00
 0000082C  77 64			ja  HaveKey	; if so, process the key

 0000082E			Peek:
					; Peek to see if we have a pending event. If so, read it.
					INVOKE PeekConsoleInput, consoleInHandle, ADDR evBuffer, 1, ADDR evEvents
 00000844  F7 45 FC			test evEvents,0FFFFh
	   0000FFFF
 0000084B  0F 84 00000095		jz   NoKey						; No pending events, so done.

					INVOKE ReadConsoleInput, consoleInHandle, ADDR evBuffer, 1, ADDR evEvents
					
 00000867  F7 45 FC			test evEvents,0FFFFh
	   0000FFFF
 0000086E  74 76			jz   NoKey						; No pending events, so done.

 00000870  66| 83 3D			cmp  evBuffer.eventType,KEY_EVENT					; Is it a key event?
	   0000072B R 01
 00000878  75 B4			jne  Peek						; No -> Peek for next event
 0000087A  F7 05 0000072F R		TEST evBuffer.Event.bKeyDown, KBDOWN_FLAG		; is it a key down event?
	   00000001
 00000884  74 A8			jz   Peek						; No -> Peek for next event

 00000886  66| A1			mov  ax,evBuffer.Event.wRepeatCount				; Set our internal repeat counter
	   00000733 R
 0000088C  66| A3			mov  evRepeat,ax
	   0000073F R

 00000892			HaveKey:
 00000892  A0 00000739 R		mov  al,evBuffer.Event.uChar.AsciiChar				; copy Ascii char to al
 00000897  8A 25 00000737 R		mov  ah,BYTE PTR evBuffer.Event.wVirtualScanCode	; copy Scan code to ah
 0000089D  66| 8B 15			mov  dx,evBuffer.Event.wVirtualKeyCode				; copy Virtual key code to dx
	   00000735 R
 000008A4  8B 1D 0000073B R		mov  ebx,evBuffer.Event.dwControlKeyState			; copy keyboard flags to ebx

					; Ignore the key press events for Shift, Ctrl, Alt, etc.
					; Don't process them unless used in combination with another key
					.IF dx == VK_SHIFT || dx == VK_CONTROL || dx == VK_MENU || \
					  dx == VK_CAPITAL || dx == VK_NUMLOCK || dx == VK_SCROLL
 000008D0  E9 FFFFFF59			  jmp Peek					; Don't process -> Peek for next event
					.ENDIF

 000008D5  E8 00000049			call  ReadKeyTranslate					; Translate scan code compatability

 000008DA  66| FF 0D			dec  evRepeat					; Decrement our repeat counter
	   0000073F R
 000008E1  66| 0B D2			or   dx,dx					; Have key: clear the Zero flag
 000008E4  EB 0E			jmp  Done

 000008E6			NoKey:
 000008E6  66| C7 05			mov  evRepeat,0					; Reset our repeat counter
	   0000073F R
	   0000
 000008EF  A9 00000000			test eax,0					; No key: set ZF=1 and quit

 000008F4			Done:
 000008F4  9C			    pushfd 					; save Zero flag
 000008F5  60			    pushad
				           					; Restore Console mode
				    INVOKE SetConsoleMode,consoleInHandle,saveFlags

				    ;Unless we call ReadKeyFlush in Windows 98, the key we just read
				    ;reappears the next time ReadString is called! We don't know why.
 00000904  E8 00000005		    call ReadKeyFlush

 00000909  61			    popad
 0000090A  9D			    popfd  					; restore Zero flag
					ret
 0000090E			ReadKey ENDP


				;------------------------------------------------------------------------------
 0000090E			ReadKeyFlush PROC
				; Flushes the console input buffer and clears our internal repeat counter.
				; Can be used to get faster keyboard reponse in arcade-style games, where
				; we don't want to processes accumulated keyboard data that would slow down
				; the program's response time.
				; Receives: nothing
				; Returns: nothing
				; By Richard Stam, used by permission.
				; Modified 4/5/03 by Irvine
				;------------------------------------------------------------------------------
					INVOKE FlushConsoleInputBuffer, consoleInHandle 	; Flush the buffer
 00000919  66| C7 05			mov    evRepeat,0							; Reset our repeat counter
	   0000073F R
	   0000
 00000922  C3				ret
 00000923			ReadKeyFlush ENDP


				;------------------------------------------------------------------------------
 00000923			ReadKeyTranslate PROC PRIVATE USES ebx ecx edx esi
				; Translates special scan codes to be compatible with DOS/BIOS return values.
				; Called directly by ReadKey.
				; Receives:
				;	al  = key Ascii code
				;	ah  = Virtual scan code
				;	dx  = Virtual key code
				;	ebx = Keyboard flags (Alt,Ctrl,Caps,etc.)
				; Returns:
				;	ah  = Updated scan code (for Alt/Ctrl/Shift & special cases)
				;	al  = Updated key Ascii code (set to 0 for special keys)
				; Written by Richard Stam, used by permission.
				; Modified 4/5/03 by Irvine
				;------------------------------------------------------------------------------

 00000741			.data  ; Special key scan code translation table
				; order: VirtualKey,NormalScan,CtrlScan,AltScan
 00000741 25 4B 73 4B		SpecialCases \
 00000745				BYTE VK_LEFT,  4Bh, 73h,  4Bh
 = 00000004			CaseSize = ($ - SpecialCases)			; Special case table element size
 00000745  27 4D 74 4D			BYTE VK_RIGHT, 4Dh, 74h,  4Dh
 00000749  26 48 8D 48			BYTE VK_UP,    48h, 8Dh,  48h
 0000074D  28 50 91 50			BYTE VK_DOWN,  50h, 91h,  50h
 00000751  21 49 84 49			BYTE VK_PRIOR, 49h, 84h,  49h 		; PgUp
 00000755  22 51 76 51			BYTE VK_NEXT,  51h, 76h,  51h 		; PgDn
 00000759  24 47 77 47			BYTE VK_HOME,  47h, 77h,  47h
 0000075D  23 4F 75 4F			BYTE VK_END,   4Fh, 75h,  4Fh
 00000761  2D 52 92 52			BYTE VK_INSERT,52h, 92h,  52h
 00000765  2E 53 93 53			BYTE VK_DELETE,53h, 93h,  53h
 00000769  6B 4E 90 4E			BYTE VK_ADD,   4Eh, 90h,  4Eh
 0000076D  6D 4A 8E 4A			BYTE VK_SUBTRACT,4Ah,8Eh, 4Ah
 00000771  7A 85 85 85			BYTE VK_F11,   85h, 85h,  85h
 00000775  7B 86 86 86			BYTE VK_F12,   86h, 86h,  86h
 00000779  BD 0C 0C 82			BYTE VK_11,    0Ch, 0Ch,  82h 		; see above
 0000077D  BB 0D 0D 83			BYTE VK_12,    0Dh, 0Dh,  83h 		; see above
 00000781  00				BYTE 0			; End of Table

 00000927			.code
 00000927  9C				pushfd					; Push flags to save ZF of ReadKey
 00000928  BE 00000000			mov  esi,0

					; Search through the special cases table
 0000092D			Search:
 0000092D  80 BE 00000741 R		cmp  SpecialCases[esi],0					; Check for end of search table
	   00
 00000934  74 3C			je   NotFound

 00000936  3A 96 00000741 R		cmp  dl,SpecialCases[esi]					; Check if special case is found
 0000093C  74 08			je   Found

 0000093E  81 C6 00000004		add  esi,CaseSize					; Increment our table index
 00000944  EB E7			jmp  Search					; Continue searching

 00000946			Found:
					.IF ebx & CTRL_MASK
 0000094E  8A A6 00000743 R		  mov  ah,SpecialCases[esi+2]					; Specify the Ctrl scan code
 00000954  B0 00			  mov  al,0					; Updated char for special keys
					.ELSEIF ebx & ALT_MASK
 00000960  8A A6 00000744 R		  mov  ah,SpecialCases[esi+3]					; Specify the Alt scan code
 00000966  B0 00			  mov  al,0					; Updated char for special keys
					.ELSE
 0000096A  8A A6 00000742 R		  mov ah,SpecialCases[esi+1]					; Specify the normal scan code
					.ENDIF
 00000970  EB 64			jmp  Done

 00000972			NotFound:
					.IF ! (ebx & KEY_MASKS)					; Done if not shift/ctrl/alt combo
 0000097A  EB 5A			  jmp  Done
					.ENDIF

					.IF dx >= VK_F1 && dx <= VK_F10				; Check for F1 to F10 keys
					  .IF ebx & CTRL_MASK
 00000990  80 C4 23			    add ah,23h					; 23h = Hex diff for Ctrl/Fn keys
					  .ELSEIF ebx & ALT_MASK
 0000099D  80 C4 2D			    add ah,2Dh					; 2Dh = Hex diff for Alt/Fn keys
					  .ELSEIF ebx & SHIFT_MASK
 000009AA  80 C4 19			    add ah,19h					; 19h = Hex diff for Shift/Fn keys
					  .ENDIF
					.ELSEIF al >= '0' && al <= '9'				; Check for Alt/1 to Alt/9
					  .IF ebx & ALT_MASK
 000009BF  80 C4 76			    add ah,76h					; 76h = Hex diff for Alt/n keys
 000009C2  B0 00			    mov al,0
					  .ENDIF
					.ELSEIF dx == VK_TAB					; Check for Shift/Tab (backtab)
					  .IF ebx & SHIFT_MASK
 000009D4  B0 00			    mov al,0					; ah already has 0Fh, al=0 for special
					  .ENDIF
					.ENDIF

 000009D6			Done:
 000009D6  9D				popfd					; Pop flags to restore ZF of ReadKey
					ret
 000009DC			ReadKeyTranslate ENDP


				;--------------------------------------------------------
 000009DC			ReadString PROC
					LOCAL bufSize:DWORD, saveFlags:DWORD, junk:DWORD
				;
				; Reads a string from the keyboard and places the characters
				; in a buffer.
				; Receives: EDX offset of the input buffer
				;           ECX = maximum characters to input (including terminal null)
				; Returns:  EAX = size of the input string.
				; Comments: Stops when Enter key (0Dh,0Ah) is pressed. If the user
				; types more characters than (ECX-1), the excess characters
				; are ignored.
				; Written by Kip Irvine and Gerald Cahill
				;
				; Last update: 11/19/92, 03/20/2003
				;--------------------------------------------------------
 00000782			.data
 00000782 00000000		_$$temp DWORD ?		; added 03/20/03
 000009E2			.code
 000009E2  60				pushad
					CheckInit
 000009E3  80 3D 00000000 R  1		cmp InitFlag,0
	   00
 000009EA  75 05	     1		jne ??0026
 000009EC  E8 FFFFFB2E	     1		call Initialize
 000009F1		     1	??0026:

 000009F1  8B FA			mov edi,edx		; set EDI to buffer offset
 000009F3  89 4D FC			mov bufSize,ecx		; save buffer size

 000009F6  52				push edx
					INVOKE ReadConsole,
					  consoleInHandle,		; console input handle
					  edx,		; buffer offset
					  ecx,		; max count
					  OFFSET bytesRead,
					  0
 00000A0B  5A				pop edx
 00000A0C  83 3D 00000261 R		cmp bytesRead,0
	   00
 00000A13  74 78			jz  L5 		; skip move if zero chars input

 00000A15  FF 0D 00000261 R		dec bytesRead		; make first adjustment to bytesRead
 00000A1B  FC				cld		; search forward
 00000A1C  8B 4D FC			mov ecx,bufSize		; repetition count for SCASB
 00000A1F  B0 0A			mov al,0Ah		; scan for 0Ah (Line Feed) terminal character
 00000A21  F2/ AE			repne scasb
 00000A23  75 11			jne L1		; if not found, jump to L1

					;if we reach this line, length of input string <= (bufsize - 2)

 00000A25  FF 0D 00000261 R		dec bytesRead		; second adjustment to bytesRead
 00000A2B  83 EF 02			sub edi,2		; 0Ah found: back up two positions
 00000A2E  3B FA			cmp edi,edx 		; don't back up to before the user's buffer
 00000A30  73 58			jae L2
 00000A32  8B FA			mov edi,edx 		; 0Ah must be the only byte in the buffer
 00000A34  EB 54			jmp L2		; and jump to L2

 00000A36  8B FA		L1:	mov edi,edx		; point to last byte in buffer
 00000A38  03 7D FC			add edi,bufSize
 00000A3B  4F				dec edi
 00000A3C  C6 07 00			mov BYTE PTR [edi],0    		; insert null byte

					; Save the current console mode
					INVOKE GetConsoleMode,consoleInHandle,ADDR saveFlags
					; Switch to single character mode
					INVOKE SetConsoleMode,consoleInHandle,0

					; Clear excess characters from the buffer, 1 byte at a time
 00000A5B			L6:	INVOKE ReadConsole,consoleInHandle,ADDR junk,1,ADDR _$$temp,0
 00000A73  8A 45 F4			mov al,BYTE PTR junk
 00000A76  3C 0A			cmp al,0Ah 		; the terminal line feed character
 00000A78  75 E1			jne L6     		; keep looking, it must be there somewhere

					INVOKE SetConsoleMode,consoleInHandle,saveFlags ; restore console mode.
 00000A88  EB 03			jmp L5

 00000A8A  C6 07 00		L2:	mov BYTE PTR [edi],0		; insert null byte

 00000A8D  61			L5:	popad
 00000A8E  A1 00000261 R		mov eax,bytesRead
					ret
 00000A95			ReadString ENDP


				;------------------------------------------------------------
 00000A95			SetTextColor PROC
				;
				; Change the color of all subsequent text output.
				; Receives: AX = attribute. Bits 0-3 are the foreground
				; 	color, and bits 4-7 are the background color.
				; Returns: nothing
				; Last update: 6/20/05
				;------------------------------------------------------------

 00000A95  60				pushad
					CheckInit	; added 6/20/05
 00000A96  80 3D 00000000 R  1		cmp InitFlag,0
	   00
 00000A9D  75 05	     1		jne ??0027
 00000A9F  E8 FFFFFA7B	     1		call Initialize
 00000AA4		     1	??0027:

				 	INVOKE SetConsoleTextAttribute, consoleOutHandle, ax

 00000AB4  61				popad
 00000AB5  C3				ret
 00000AB6			SetTextColor ENDP


				;---------------------------------------------------------
 00000AB6			StrLength PROC
				;
				; Returns the length of a null-terminated string.
				; Receives: EDX points to the string.
				; Returns: EAX = string length.
				; Last update: 6/9/05
				;---------------------------------------------------------
 00000AB6  52				push	edx
 00000AB7  B8 00000000			mov	eax,0     	; character count

 00000ABC  80 3A 00		L1:	cmp	BYTE PTR [edx],0	; end of string?
 00000ABF  74 04			je	L2	; yes: quit
 00000AC1  42				inc	edx	; no: point to next
 00000AC2  40				inc	eax	; add 1 to count
 00000AC3  EB F7			jmp	L1

 00000AC5  5A			L2: pop	edx
 00000AC6  C3				ret
 00000AC7			StrLength ENDP


				;----------------------------------------------------------
 00000AC7			Str_compare PROC USES eax edx esi edi,
					string1:PTR BYTE,
					string2:PTR BYTE
				;
				; Compare two strings.
				; Returns nothing, but the Zero and Carry flags are affected
				; exactly as they would be by the CMP instruction.
				; Last update: 1/18/02
				;-----------------------------------------------------
 00000ACE  8B 75 08		    mov esi,string1
 00000AD1  8B 7D 0C		    mov edi,string2

 00000AD4  8A 06		L1: mov  al,[esi]
 00000AD6  8A 17		    mov  dl,[edi]
 00000AD8  3C 00		    cmp  al,0    		; end of string1?
 00000ADA  75 07		    jne  L2      		; no
 00000ADC  80 FA 00		    cmp  dl,0    		; yes: end of string2?
 00000ADF  75 02		    jne  L2      		; no
 00000AE1  EB 06		    jmp  L3      		; yes, exit with ZF = 1

 00000AE3  46			L2: inc  esi      		; point to next
 00000AE4  47			    inc  edi
 00000AE5  38 D0		    cmp  al,dl   		; chars equal?
 00000AE7  74 EB		    je   L1      		; yes: continue loop
				                 		; no: exit with flags set
 00000AE9			L3: ret
 00000AF1			Str_compare ENDP


				;---------------------------------------------------------
 00000AF1			Str_copy PROC USES eax ecx esi edi,
				 	source:PTR BYTE, 		; source string
				 	target:PTR BYTE		; target string
				;
				; Copy a string from source to target.
				; Requires: the target string must contain enough
				;           space to hold a copy of the source string.
				; Last update: 1/18/02
				;----------------------------------------------------------
					INVOKE Str_length,source 		; EAX = length source
 00000B00  8B C8			mov ecx,eax		; REP count
 00000B02  41				inc ecx         		; add 1 for null byte
 00000B03  8B 75 08			mov esi,source
 00000B06  8B 7D 0C			mov edi,target
 00000B09  FC				cld               		; direction = up
 00000B0A  F3/ A4			rep movsb      		; copy the string
					ret
 00000B14			Str_copy ENDP


				;---------------------------------------------------------
 00000B14			Str_length PROC USES edi,
					pString:PTR BYTE	; pointer to string
				;
				; Return the length of a null-terminated string.
				; Receives: pString - pointer to a string
				; Returns: EAX = string length
				; Last update: 1/18/02
				;---------------------------------------------------------
 00000B18  8B 7D 08			mov edi,pString
 00000B1B  B8 00000000			mov eax,0     	; character count
 00000B20			L1:
 00000B20  80 3F 00			cmp BYTE PTR [edi],0	; end of string?
 00000B23  74 04			je  L2	; yes: quit
 00000B25  47				inc edi	; no: point to next
 00000B26  40				inc eax	; add 1 to count
 00000B27  EB F7			jmp L1
 00000B29			L2: ret
 00000B2E			Str_length ENDP


				;-----------------------------------------------------------
 00000B2E			Str_trim PROC USES eax ecx edi,
					pString:PTR BYTE,		; points to string
					char:BYTE		; char to remove
				;
				; Remove all occurences of a given character from
				; the end of a string.
				; Returns: nothing
				; Last update: 1/18/02
				;-----------------------------------------------------------
 00000B34  8B 7D 08			mov  edi,pString
					INVOKE Str_length,edi		; returns length in EAX
 00000B3D  83 F8 00			cmp  eax,0		; zero-length string?
 00000B40  74 12			je   L2		; yes: exit
 00000B42  8B C8			mov  ecx,eax		; no: counter = string length
 00000B44  48				dec  eax
 00000B45  03 F8			add  edi,eax		; EDI points to last char
 00000B47  8A 45 0C			mov  al,char		; char to trim
 00000B4A  FD				std		; direction = reverse
 00000B4B  F3/ AE			repe scasb		; skip past trim character
 00000B4D  75 01			jne  L1		; removed first character?
 00000B4F  4F				dec  edi		; adjust EDI: ZF=1 && ECX=0
 00000B50  C6 47 02 00		L1:	mov  BYTE PTR [edi+2],0		; insert null byte
 00000B54			L2:	ret
 00000B5B			Str_trim ENDP


				;---------------------------------------------------
 00000B5B			Str_ucase PROC USES eax esi,
					pString:PTR BYTE
				; Convert a null-terminated string to upper case.
				; Receives: pString - a pointer to the string
				; Returns: nothing
				; Last update: 1/18/02
				;---------------------------------------------------
 00000B60  8B 75 08			mov esi,pString
 00000B63			L1:
 00000B63  8A 06			mov al,[esi]		; get char
 00000B65  3C 00			cmp al,0		; end of string?
 00000B67  74 0E			je  L3		; yes: quit
 00000B69  3C 61			cmp al,'a'		; below "a"?
 00000B6B  72 07			jb  L2
 00000B6D  3C 7A			cmp al,'z'		; above "z"?
 00000B6F  77 03			ja  L2
 00000B71  80 26 DF			and BYTE PTR [esi],11011111b	; convert the char

 00000B74  46			L2:	inc esi		; next char
 00000B75  EB EC			jmp L1

 00000B77			L3: ret
 00000B7D			Str_ucase ENDP


				;------------------------------------------------------
 00000B7D			WaitMsg PROC
				;
				; Displays a prompt and waits for the user to press a key.
				; Receives: nothing
				; Returns: nothing
				; Last update: 6/9/05
				;------------------------------------------------------
 00000786			.data
 00000786 50 72 65 73 73	waitmsgstr BYTE "Press any key to continue...",0
	   20 61 6E 79 20
	   6B 65 79 20 74
	   6F 20 63 6F 6E
	   74 69 6E 75 65
	   2E 2E 2E 00
 00000B7D			.code
 00000B7D  60				pushad

 00000B7E  BA 00000786 R		mov	edx,OFFSET waitmsgstr
 00000B83  E8 00000374			call	WriteString
 00000B88  E8 FFFFFB76			call	ReadChar	

 00000B8D  61				popad
 00000B8E  C3				ret
 00000B8F			WaitMsg ENDP


				;------------------------------------------------------
 00000B8F			WriteBin PROC
				;
				; Writes a 32-bit integer to the console window in
				; binary format. Converted to a shell that calls the
				; WriteBinB procedure, to be compatible with the
				; library documentation in Chapter 5.
				; Receives: EAX = the integer to write
				; Returns: nothing
				;
				; Last update: 11/18/02
				;------------------------------------------------------

 00000B8F  53				push ebx
 00000B90  BB 00000004			mov  ebx,4	; select doubleword format
 00000B95  E8 00000002			call WriteBinB
 00000B9A  5B				pop  ebx

 00000B9B  C3				ret
 00000B9C			WriteBin ENDP


				;------------------------------------------------------
 00000B9C			WriteBinB PROC
				;
				; Writes a 32-bit integer to the console window in
				; binary format.
				; Receives: EAX = the integer to write
				;           EBX = display size (1,2,4)
				; Returns: nothing
				;
				; Last update: 11/18/02  (added)
				;------------------------------------------------------
 00000B9C  60				pushad

 00000B9D  83 FB 01		    cmp   ebx,1   	; ensure EBX is 1, 2, or 4
 00000BA0  74 0A		    jz    WB0
 00000BA2  83 FB 02		    cmp   ebx,2
 00000BA5  74 05		    jz    WB0
 00000BA7  BB 00000004		    mov   ebx,4   	; set to 4 (default) even if it was 4
 00000BAC			WB0:
 00000BAC  8B CB		    mov   ecx,ebx
 00000BAE  D1 E1		    shl   ecx,1   	; number of 4-bit groups in low end of EAX
 00000BB0  83 FB 04		    cmp   ebx,4
 00000BB3  74 0B		    jz    WB0A
 00000BB5  C1 C8 08		    ror   eax,8   	; assume TYPE==1 and ROR byte
 00000BB8  83 FB 01		    cmp   ebx,1
 00000BBB  74 03		    jz    WB0A    	; good assumption
 00000BBD  C1 C8 08		    ror   eax,8   	; TYPE==2 so ROR another byte
 00000BC0			WB0A:

 00000BC0  BE 00000061 R		mov   esi,OFFSET buffer

 00000BC5			WB1:
 00000BC5  51				push  ecx	; save loop count

 00000BC6  B9 00000004			mov   ecx,4	; 4 bits in each group
 00000BCB			WB1A:
 00000BCB  D1 E0			shl   eax,1	; shift EAX left into Carry flag
 00000BCD  C6 06 30			mov   BYTE PTR [esi],'0'	; choose '0' as default digit
 00000BD0  73 03			jnc   WB2	; if no carry, then jump to L2
 00000BD2  C6 06 31			mov   BYTE PTR [esi],'1'	; else move '1' to DL
 00000BD5			WB2:
 00000BD5  46				inc   esi
 00000BD6  E2 F3			Loop  WB1A	; go to next bit within group

 00000BD8  C6 06 20			mov   BYTE PTR [esi],' '  	; insert a blank space
 00000BDB  46				inc   esi	; between groups
 00000BDC  59				pop   ecx	; restore outer loop count
 00000BDD  E2 E6			loop  WB1	; begin next 4-bit group

 00000BDF  4E			    dec  esi    	; eliminate the trailing space
 00000BE0  C6 06 00			mov  BYTE PTR [esi],0	; insert null byte at end
 00000BE3  BA 00000061 R	    mov  edx,OFFSET buffer	; display the buffer
 00000BE8  E8 0000030F			call WriteString

 00000BED  61				popad
 00000BEE  C3				ret
 00000BEF			WriteBinB ENDP


				;------------------------------------------------------
 00000BEF			WriteChar PROC
				;
				; Write a character to the console window
				; Recevies: AL = character
				; Last update: 10/30/02
				; Note: WriteConole will not work unless direction flag is clear.
				;------------------------------------------------------
 00000BEF  60				pushad
 00000BF0  9C				pushfd	; save flags
					CheckInit
 00000BF1  80 3D 00000000 R  1		cmp InitFlag,0
	   00
 00000BF8  75 05	     1		jne ??0028
 00000BFA  E8 FFFFF920	     1		call Initialize
 00000BFF		     1	??0028:

 00000BFF  A2 00000061 R		mov  buffer,al

 00000C04  FC				cld	; clear direction flag
					INVOKE WriteConsole,
					  consoleOutHandle,	; console output handle
					  OFFSET buffer,	; points to string
					  1,	; string length
					  OFFSET bytesWritten,  	; returns number of bytes written
					  0

 00000C1E  9D				popfd	; restore flags
 00000C1F  61				popad
 00000C20  C3				ret
 00000C21			WriteChar ENDP


				;-----------------------------------------------------
 00000C21			WriteDec PROC
				;
				; Writes an unsigned 32-bit decimal number to
				; the console window. Input parameters: EAX = the
				; number to write.
				; Last update: 6/8/2005
				;------------------------------------------------------
 000007A3			.data
				; There will be as many as 10 digits.
 = 0000000C			WDBUFFER_SIZE = 12

 000007A3  0000000C [		bufferL BYTE WDBUFFER_SIZE DUP(?),0
	    00
	   ] 00

 00000C21			.code
 00000C21  60				pushad
					CheckInit
 00000C22  80 3D 00000000 R  1		cmp InitFlag,0
	   00
 00000C29  75 05	     1		jne ??0029
 00000C2B  E8 FFFFF8EF	     1		call Initialize
 00000C30		     1	??0029:

 00000C30  B9 00000000			mov   ecx,0           ; digit counter
 00000C35  BF 000007A3 R		mov   edi,OFFSET bufferL
 00000C3A  83 C7 0B			add   edi,(WDBUFFER_SIZE - 1)
 00000C3D  BB 0000000A			mov   ebx,10	; decimal number base

 00000C42  BA 00000000		WI1:mov   edx,0          	; clear dividend to zero
 00000C47  F7 F3			div   ebx            	; divide EAX by the radix

 00000C49  92				xchg  eax,edx        	; swap quotient, remainder
 00000C4A  E8 00000349			call  AsciiDigit     	; convert AL to ASCII
 00000C4F  88 07			mov   [edi],al       	; save the digit
 00000C51  4F				dec   edi            	; back up in buffer
 00000C52  92				xchg  eax,edx        	; swap quotient, remainder

 00000C53  41				inc   ecx            	; increment digit count
 00000C54  0B C0			or    eax,eax        	; quotient = 0?
 00000C56  75 EA			jnz   WI1            	; no, divide again

					 ; Display the digits (CX = count)
 00000C58			WI3:
 00000C58  47				 inc   edi
 00000C59  8B D7			 mov   edx,edi
 00000C5B  E8 0000029C			 call  WriteString

 00000C60			WI4:
 00000C60  61				 popad	; restore 32-bit registers
 00000C61  C3				 ret
 00000C62			WriteDec ENDP


				;------------------------------------------------------
 00000C62			WriteHex PROC
				;
				; Writes an unsigned 32-bit hexadecimal number to
				; the console window.
				; Input parameters: EAX = the number to write.
				; Shell interface for WriteHexB, to retain compatibility
				; with the documentation in Chapter 5.
				;
				; Last update: 11/18/02
				;------------------------------------------------------
 00000C62  53				push ebx
 00000C63  BB 00000004			mov  ebx,4
 00000C68  E8 00000002			call WriteHexB
 00000C6D  5B				pop  ebx
 00000C6E  C3				ret
 00000C6F			WriteHex ENDP


				;------------------------------------------------------
 00000C6F			WriteHexB PROC
					LOCAL displaySize:DWORD
				;
				; Writes an unsigned 32-bit hexadecimal number to
				; the console window.
				; Receives: EAX = the number to write. EBX = display size (1,2,4)
				; Returns: nothing
				;
				; Last update: 11/18/02
				;------------------------------------------------------

 = 00000008			DOUBLEWORD_BUFSIZE = 8

 000007B0			.data
 000007B0  00000008 [		bufferLHB BYTE DOUBLEWORD_BUFSIZE DUP(?),0
	    00
	   ] 00

 00000C75			.code
 00000C75  60				pushad               	; save all 32-bit data registers
 00000C76  89 5D FC			mov displaySize,ebx	; save component size

				; Clear unused bits from EAX to avoid a divide overflow.
				; Also, verify that EBX contains either 1, 2, or 4. If any
				; other value is found, default to 4.

				.IF EBX == 1	; check specified display size
 00000C7E  25 000000FF			and  eax,0FFh	; byte == 1
				.ELSE
					.IF EBX == 2
 00000C8A  25 0000FFFF			  and  eax,0FFFFh	; word == 2
					.ELSE
 00000C91  C7 45 FC			  mov displaySize,4	; default (doubleword) == 4
	   00000004
					.ENDIF
				.ENDIF

					CheckInit
 00000C98  80 3D 00000000 R  1		cmp InitFlag,0
	   00
 00000C9F  75 05	     1		jne ??002A
 00000CA1  E8 FFFFF879	     1		call Initialize
 00000CA6		     1	??002A:

 00000CA6  8B 7D FC			mov   edi,displaySize	; let EDI point to the end of the buffer:
 00000CA9  D1 E7			shl   edi,1	; multiply by 2 (2 digits per byte)
 00000CAB  C6 87 000007B0 R		mov   bufferLHB[edi],0 	; store null string terminator
	   00
 00000CB2  4F				dec   edi	; back up one position

 00000CB3  B9 00000000			mov   ecx,0           	; digit counter
 00000CB8  BB 00000010			mov   ebx,16	; hexadecimal base (divisor)

 00000CBD			L1:
 00000CBD  BA 00000000			mov   edx,0          	; clear upper dividend
 00000CC2  F7 F3			div   ebx            	; divide EAX by the base

 00000CC4  92				xchg  eax,edx        	; swap quotient, remainder
 00000CC5  E8 000002CE			call  AsciiDigit     	; convert AL to ASCII
 00000CCA  88 87 000007B0 R		mov   bufferLHB[edi],al       ; save the digit
 00000CD0  4F				dec   edi             	; back up in buffer
 00000CD1  92				xchg  eax,edx        	; swap quotient, remainder

 00000CD2  41				inc   ecx             	; increment digit count
 00000CD3  0B C0			or    eax,eax        	; quotient = 0?
 00000CD5  75 E6			jnz   L1           	; no, divide again

					 ; Insert leading zeros

 00000CD7  8B 45 FC			mov   eax,displaySize	; set EAX to the
 00000CDA  D1 E0			shl   eax,1	; number of digits to print
 00000CDC  2B C1			sub   eax,ecx	; subtract the actual digit count
 00000CDE  74 0C			jz    L3           	; display now if no leading zeros required
 00000CE0  8B C8			mov   ecx,eax         	; CX = number of leading zeros to insert

 00000CE2			L2:
 00000CE2  C6 87 000007B0 R		mov   bufferLHB[edi],'0'	; insert a zero
	   30
 00000CE9  4F				dec   edi                  	; back up
 00000CEA  E2 F6			loop  L2                	; continue the loop

					; Display the digits. ECX contains the number of
					; digits to display, and EDX points to the first digit.
 00000CEC			L3:
 00000CEC  8B 4D FC			mov   ecx,displaySize	; output format size
 00000CEF  D1 E1			shl   ecx,1         	; multiply by 2
 00000CF1  47				inc   edi
 00000CF2  BA 000007B0 R		mov   edx,OFFSET bufferLHB
 00000CF7  03 D7			add   edx,edi
 00000CF9  E8 000001FE			call  WriteString

 00000CFE  61				popad	; restore 32-bit registers
					ret
 00000D01			WriteHexB ENDP


				;-----------------------------------------------------
 00000D01			WriteInt PROC
				;
				; Writes a 32-bit signed binary integer to the console window
				; in ASCII decimal.
				; Receives: EAX = the integer
				; Returns:  nothing
				; Comments: Displays a leading sign, no leading zeros.
				; Last update: 7/11/01
				;-----------------------------------------------------
 = 0000000C			WI_Bufsize = 12
 = 00000001			true  =   1
 = 00000000			false =   0
 000007B9			.data
 000007B9  0000000C [		buffer_B  BYTE  WI_Bufsize DUP(0),0  ; buffer to hold digits
	    00
	   ] 00
 000007C6 00			neg_flag  BYTE  ?

 00000D01			.code
 00000D01  60				pushad
					CheckInit
 00000D02  80 3D 00000000 R  1		cmp InitFlag,0
	   00
 00000D09  75 05	     1		jne ??002B
 00000D0B  E8 FFFFF80F	     1		call Initialize
 00000D10		     1	??002B:

 00000D10  C6 05 000007C6 R		mov   neg_flag,false    ; assume neg_flag is false
	   00
 00000D17  0B C0			or    eax,eax             ; is AX positive?
 00000D19  79 09			jns   WIS1              ; yes: jump to B1
 00000D1B  F7 D8			neg   eax                ; no: make it positive
 00000D1D  C6 05 000007C6 R		mov   neg_flag,true     ; set neg_flag to true
	   01

 00000D24			WIS1:
 00000D24  B9 00000000			mov   ecx,0              ; digit count = 0
 00000D29  BF 000007B9 R		mov   edi,OFFSET buffer_B
 00000D2E  83 C7 0B			add   edi,(WI_Bufsize-1)
 00000D31  BB 0000000A			mov   ebx,10             ; will divide by 10

 00000D36			WIS2:
 00000D36  BA 00000000			mov   edx,0              ; set dividend to 0
 00000D3B  F7 F3			div   ebx                ; divide AX by 10
 00000D3D  80 CA 30			or    dl,30h            ; convert remainder to ASCII
 00000D40  4F				dec   edi                ; reverse through the buffer
 00000D41  88 17			mov   [edi],dl           ; store ASCII digit
 00000D43  41				inc   ecx                ; increment digit count
 00000D44  0B C0			or    eax,eax             ; quotient > 0?
 00000D46  75 EE			jnz   WIS2              ; yes: divide again

					; Insert the sign.

 00000D48  4F				dec   edi	; back up in the buffer
 00000D49  41				inc   ecx               	; increment counter
 00000D4A  C6 07 2B			mov   BYTE PTR [edi],'+' 	; insert plus sign
 00000D4D  80 3D 000007C6 R		cmp   neg_flag,false    	; was the number positive?
	   00
 00000D54  74 03			jz    WIS3              	; yes
 00000D56  C6 07 2D			mov   BYTE PTR [edi],'-' 	; no: insert negative sign

 00000D59			WIS3:	; Display the number
 00000D59  8B D7			mov  edx,edi
 00000D5B  E8 0000019C			call WriteString

 00000D60  61				popad
 00000D61  C3				ret
 00000D62			WriteInt ENDP

 = 00000001			NoNameCode = 1;          Special nonprintable code to signal that
				              ;          WriteStackFrame was called.
 = 00000040			WriteStackFrameNameSize = 64   ; Size of WriteStackFrameName's stack frame
 = 00000014			WriteStackFrameSize = 20       ; Size of WriteStackFrame's stack frame

 00000D62			.code
				;---------------------------------------------------
 00000D62			WriteStackFrameName PROC USES EAX EBX ECX EDX ESI,
				           numParam:DWORD,     ; number of parameters passed to the procedure
				           numLocalVal: DWORD, ; number of DWord local variables
				           numSavedReg: DWORD, ; number of saved registers
				           procName: PTR BYTE  ; pointer to name of procedure
				       LOCAL theReturn:  DWORD, theBase:  DWORD, \
				             firstLocal: DWORD, firstSaved: DWORD, \
				             specialFirstSaved: DWORD

				; When called properly from a procedure with a stack frame, it prints
				; out the stack frame for the procedure.  Each item is labeled with its
				; purpose: parameter, return address, saved ebp, local variable or saved
				; register.   The items pointed by ebp and esp are marked.

				; Requires:  The procedure has a stack frame including the return address
				;            and saved base pointer.
				;            It is suffient that procedure's PROC statement includes either
				;            at least one local variable or one parameter.  If the procedure's
				;            PROC statement does not include either of these items, it is
				;            sufficient if the procedure begins with
				;                  push ebp
				;                  mov  ebp, esp
				;            and the stack frame is completed before this procedure is
				;            INVOKEd providing the procedure does not have a USES clause.
				;            If there is a USES clause, but no parameters or local variables,
				;            the modified structure is printed
				; Parameters passed on stack using STDCALL:
				;            numParam:    number of parameters
				;            numLocalVal: number of DWORDS of local variables
				;            numSavedReg: number of saved registers
				;            ptrProcName: pointer to name of procedure
				; Returns:  nothing
				; Sample use:
				;         myProc PROC USES ebx, ecx, edx      ; saves 3 registers
				;                   val:DWORD;                ; has 1 parameter
				;               LOCAL a:DWORD, b:DWORD        ; has 2 local varables
				;         .data
				;         myProcName  BYTE "myProc", 0
				;         .code
				;               INVOKE writeStackFrameName, 1, 2, 3, ADDR myProcName
				;  Comment:  The number parameters are ordered by the order of the
				;            corresponding items in the stack frame.
				;
				; Author:  James Brink, Pacific Lutheran University
				; Last update: 4/6/2005
				;---------------------------------------------------
 000007C7			.data
 000007C7 53 74 61 63 6B	LblStack  BYTE "Stack Frame ",  0
	   20 46 72 61 6D
	   65 20 00
 000007D4 66 6F 72 20 00	LblFor    Byte "for ", 0
 000007D9 20 20 65 62 70	LblEbp    BYTE "  ebp", 0             ; used for offsets from ebp
	   00
 000007DF 20 28 70 61 72	LblParam  BYTE " (parameter)", 0
	   61 6D 65 74 65
	   72 29 00
 000007EC 20 28 73 61 76	LblEbpPtr BYTE " (saved ebp) <--- ebp", 0
	   65 64 20 65 62
	   70 29 20 3C 2D
	   2D 2D 20 65 62
	   70 00
 00000802 20 28 73 61 76	LblSaved  BYTE " (saved register)", 0
	   65 64 20 72 65
	   67 69 73 74 65
	   72 29 00
 00000814 20 28 6C 6F 63	LblLocal  BYTE " (local variable)", 0
	   61 6C 20 76 61
	   72 69 61 62 6C
	   65 29 00
 00000826 20 28 72 65 74	LblReturn BYTE " (return address)", 0
	   75 72 6E 20 61
	   64 64 72 65 73
	   73 29 00
 00000838 20 3C 2D 2D 2D	LblEsp    BYTE " <--- esp", 13, 10, 0 ; adds blank line at end of stack frame
	   20 65 73 70 0D
	   0A 00
 00000844 54 68 65 20 73	BadStackFrameMsg BYTE "The stack frame is invalid", 0
	   74 61 63 6B 20
	   66 72 61 6D 65
	   20 69 73 20 69
	   6E 76 61 6C 69
	   64 00
 00000D6D			.code
				        ;  register usage:
				        ;  eax:  value to be printed
				        ;  ebx:  offset from ebp
				        ;  ecx:  item counter
				        ;  edx:  location of string being printed
				        ;  esi:  memory location of stack frame item

				        ; print title
 00000D6D  BA 000007C7 R		mov  edx, OFFSET LblStack
 00000D72  E8 00000185			call writeString
 00000D77  8B 75 14			mov  esi, procName
					          ; NOTE:  esi must not be changed until we get to
					          ;        the section for calculating the location
					          ;        of the caller's ebp at L0a:
 00000D7A  80 3E 00			cmp  BYTE PTR [esi], 0      ; is the name string blank?
 00000D7D  74 17			je   L0                     ; if so, just go to a new line
 00000D7F  80 3E 01			cmp  BYTE PTR [esi], NoNameCode
					                            ; is the name the special code
					                            ; from WriteStackFrame?
 00000D82  74 12			je   L0                     ; if so, just go to a new line
 00000D84  BA 000007D4 R		mov  edx, OFFSET LblFor     ; if not, add "for "
 00000D89  E8 0000016E			call writeString
 00000D8E  8B 55 14			mov  edx, procName          ; and print name
 00000D91  E8 00000166			call writeString
 00000D96  E8 FFFFF34A		L0:	call crlf
 00000D9B  E8 FFFFF345			call crlf

 00000DA0  B9 00000000		        mov  ecx, 0            ; initialize sum of items in stack frame
 00000DA5  BB 00000000		        mov  ebx, 0            ; initialize sum of items in stack frame
				                               ;    preceding the base pointer

				        ; check for special stack frame condition
 00000DAA  8B 45 0C		        mov  eax, numLocalVal  ; Special condition:  numLocalVal = 0
 00000DAD  83 F8 00		        cmp  eax, 0
 00000DB0  77 10		        ja   Normal

 00000DB2  8B 45 08		        mov  eax, numParam     ; Special condition:  numParm = 0
 00000DB5  83 F8 00		        cmp  eax, 0
 00000DB8  77 08		        ja   Normal

 00000DBA  8B 45 10		        mov  eax, numSavedReg  ; Special condition:  numSaveReg > 0
 00000DBD  83 F8 00		        cmp  eax, 0
 00000DC0  77 2F		        ja   Special

 00000DC2  8B 45 10		Normal:	mov  eax, numSavedReg  ; get number of parameters
 00000DC5  03 C8			add  ecx, eax          ; add to number of items in stack frame
 00000DC7  89 4D F0			mov  firstSaved, ecx   ; save item number of the first saved register
 00000DCA  C7 45 EC			mov  specialFirstSaved, 0
	   00000000
					                       ; no special saved registers

 00000DD1  8B 45 0C			mov  eax, numLocalVal  ; get number of local variable DWords
 00000DD4  03 C8			add  ecx, eax          ; add to number of items in stack frame
 00000DD6  89 4D F4			mov  firstLocal, ecx   ; save item number of first local variable

 00000DD9  83 C1 01			add  ecx, 1            ; add 1 for the saved ebp
 00000DDC  89 4D F8			mov  theBase, ecx      ; save item number of the base pointer

 00000DDF  83 C1 01			add  ecx, 1            ; add 1 for the return address
 00000DE2  83 C3 01			add  ebx, 1            ; add 1 for items stored above ebp                                                                 ; add for the return address/preceding ebp
 00000DE5  89 4D FC			mov  theReturn, ecx    ; save item number of the return pointer

 00000DE8  8B 45 08			mov  eax, numParam     ; get number of parameters
 00000DEB  03 C8			add  ecx, eax          ; add to number of items in stack frame
 00000DED  03 D8			add  ebx, eax          ; add for the parameters/preceding ebp

 00000DEF  EB 26			jmp  L0z

 00000DF1			Special:
				        ; MASM does not create a stack frame under these conditions:
				        ;   The number of parameters is 0
				        ;   The number of local variables is 0
				        ;   The number of saved (USES) registers is positive.
				        ;   The following assumes the procedure processed ebp manually
				        ;   because MASM does not push it under these conditions.
 00000DF1  89 4D F0		        mov  firstSaved, ecx   ; there are no "regular" saved registers
 00000DF4  89 4D F4		        mov  firstLocal, ecx   ; there are no local variables

 00000DF7  83 C1 01		        add  ecx, 1            ; add 1 for the saved ebp
 00000DFA  89 4D F8		        mov  theBase, ecx      ; save item number of the base pointer

 00000DFD  8B 45 10		        mov  eax, numSavedReg  ; get number of saved registers
 00000E00  03 C8		        add  ecx, eax          ; add to number of items in the stack frame
 00000E02  03 D8		        add  ebx, eax          ; add for the items preceding ebp
 00000E04  89 4D EC		        mov  specialFirstSaved, ecx

 00000E07  83 C1 01			add  ecx, 1            ; add 1 for the return address
 00000E0A  83 C3 01			add  ebx, 1            ; add 1 for items stored above ebp                                                                 ; add for the return address/preceding ebp
 00000E0D  89 4D FC			mov  theReturn, ecx    ; save item number of the return pointer

 00000E10  8B C4		        mov  eax, esp
 00000E12  83 C0 2C		        add  eax, 44
 00000E15  3B C6		        cmp  eax, esi

 00000E17			L0z:
					;  ecx now contains the number of items in the stack frame
				        ;  ebx now contains the number of items preceding the base pointer

					; determine the size of those items preceding the base pointer
 00000E17  C1 E3 02			shl  ebx, 2            ; multiply by 4

				        ; determine location of caller's saved ebp
 00000E1A  80 3E 01		L0a:	cmp  BYTE PTR [esi], NoNameCode
					                       ; check for special code
 00000E1D  8B 75 00		L0b:    mov  esi, [ebp]        ; get the ebp (1 indirection
				                               ; mov does not change flags
 00000E20  75 02		        jne  L0c               ; if not special code, skip the next step
 00000E22  8B 36		        mov  esi, [esi]        ; 2nd indirection if called by WriteStackFrame
 00000E24			L0c:                           ; esi has pointer into caller's stack frame
				;   At this point esi contains the location for the caller's saved ebp

				;   Check special case to make sure ebp and esp agree.
				;   Printing the stack frame cannot be printed if ebp has not been pushed
 00000E24  8B 45 EC		        mov  eax, specialFirstSaved ; Was this a special case?
 00000E27  83 F8 00		        cmp  eax, 0           ; If so specialFirstSaved would be 0
 00000E2A  74 14		        je   L0e              ; If not, continue normal processing
 00000E2C  8B C4		        mov  eax, esp         ; Calculate loc. of last entry before
				                              ; of WriteStackFrameNames stack frame
 00000E2E  83 C0 40		        add  eax, WriteStackFrameNameSize
 00000E31  3B C6		        cmp  eax, esi         ; does it equal the location of the base pointer?
 00000E33  74 0B		        je   L0e              ; if so, continue normal processing
				                              ; if not chec to see if procedure was called
				                              ; by writeStackFrame
 00000E35  83 C0 14		        add  eax, WriteStackFrameSize
 00000E38  3B C6		        cmp  eax, esi         ; does it equal the location of the base pointer?
 00000E3A  0F 85 00000089	        jne  badStackFrame    ; if not, the stack frame is invalid
				                              ; These are not perfect test as we haven't
				                              ; checked to see which case we are in.

				; Continue normal processing by calculating its stack frame size

 00000E40  03 F3		L0e:    add  esi, ebx          ; calculate beginning of the caller's stack
				                               ; frame (highest memory used)


				 	; *** loop to print stack frame
				 	; Note:  the order of some the following checks is important                                                                                                                                                                                  ck frame  ***
 00000E42			L1:	; write value and beginning offset from basepointer
 00000E42  8B 06		        mov  eax, [esi]        ; write item in stack frame
 00000E44  E8 FFFFFE19			call writeHex
 00000E49  BA 000007D9 R		mov  edx, OFFSET LblEbp ; write " ebp"
 00000E4E  E8 000000A9			call writeString
 00000E53  8B C3			mov  eax, ebx          ; write offset from base pointer
 00000E55  E8 FFFFFEA7			call writeInt
					; check for special labels
 00000E5A  3B 4D FC			cmp  ecx, theReturn    ; check for return address item
 00000E5D  75 07			jne  L2
 00000E5F  BA 00000826 R		mov  edx, OFFSET LblReturn
 00000E64  EB 35			jmp  LPrint

 00000E66  3B 4D F8		L2:     cmp  ecx, theBase      ; check for base pointer
 00000E69  75 07		        jne  L2a
 00000E6B  BA 000007EC R	        mov  edx, OFFSET LblEbpPtr
 00000E70  EB 29		        jmp  LPrint

 00000E72  3B 4D EC		L2a:    cmp  ecx, specialFirstSaved ; Check for special saved registers
 00000E75  77 07			ja   L3
 00000E77  BA 00000802 R		mov  edx, OFFSET LblSaved
 00000E7C  EB 1D			jmp  LPrint

 00000E7E  3B 4D F0		L3:     cmp  ecx, firstSaved   ; check for saved registers
 00000E81  77 07		        ja   L4
 00000E83  BA 00000802 R	        mov  edx, OFFSET LblSaved
 00000E88  EB 11		        jmp  LPrint
 00000E8A  3B 4D F4		L4:     cmp  ecx, firstLocal   ; check for local variables
 00000E8D  77 07		        ja   L5
 00000E8F  BA 00000814 R	        mov  edx, OFFSET LblLocal
 00000E94  EB 05		        jmp  LPrint
 00000E96  BA 000007DF R	L5:     mov  edx, OFFSET LblParam
 00000E9B  E8 0000005C		LPrint: call writeString
 00000EA0  83 F9 01		        cmp  ecx, 1            ; check for last item in stack frame
 00000EA3  75 0A		        jne  LDone
 00000EA5  BA 00000838 R	        mov  edx, OFFSET LblEsp
 00000EAA  E8 0000004D		        call writeString
 00000EAF			LDone:  ; complete output for line
 00000EAF  E8 FFFFF231			call crlf
					; get ready for the next line
 00000EB4  83 EE 04			sub  esi, 4         ; decrement memory location by 4
 00000EB7  83 EB 04			sub  ebx, 4         ; decrement offset by 4
 00000EBA  E2 02			loop LDoneX
 00000EBC  EB 02			jmp  Return
 00000EBE  EB 82		LDoneX: jmp  L1
 00000EC0			Return:
					ret

				; Stack frame invalid
 00000EC9			BadStackFrame:
 00000EC9  8D 15 00000844 R	        lea  edx, BadStackFrameMsg
				                            ; load message
 00000ECF  E8 00000028		        call writeString    ; write message
 00000ED4  E8 FFFFF20C		        call crlf
				        ret	            ; return without printing stack frame

 00000EE2			WriteStackFrameName ENDP

				;---------------------------------------------------

 00000EE2			WriteStackFrame PROC,
				           numParam:DWORD,     ; number of parameters passed to the procedure
				           numLocalVal: DWORD, ; number of DWord local variables
				           numSavedReg: DWORD  ; number of saved registers

				; When called properly from a procedure with a stack frame, it prints
				; out the stack frame for the procedure.  Each item is labeled with its
				; purpose: parameter, return address, saved ebp, local variable or saved
				; register.   The items pointed by ebp and esp are marked.

				; Requires:  The procedure has a stack frame including the return address
				;            and saved base pointer.
				;            It is suffient that procedure's PROC statement includes either
				;            at least one local variable or one parameter.  If the procedure's
				;            PROC statement does not include either of these items, it is
				;            sufficient if the procedure begins with
				;                  push ebp
				;                  mov  ebp, esp
				;            and the stack frame is completed before this procedure is
				;            INVOKEd providing the procedure does not have a USES clause.
				;            If there is a USES clause, but no parameters or local variables,
				;            the modified structure is printed
				; Parameters passed on stack using STDCALL:
				;            numParam:    number of parameters
				;            numLocalVal: number of DWORDS of local variables
				;            numSavedReg: number of saved registers
				; Returns:  nothing
				; Sample use:
				;         myProc PROC USES ebx, ecx, edx      ; saves 3 registers
				;                   val:DWORD;                ; has 1 parameter
				;               LOCAL a:DWORD, b:DWORD        ; has 2 local varables
				;         .data
				;         myProcName  BYTE "myProc", 0
				;         .code
				;               INVOKE writeStackFrame, 1, 2, 3
				;
				; Comments:  The parameters are ordered by the order of the corresponding
				;            items in the stack frame.
				;
				; Author:  James Brink, Pacific Lutheran University
				; Last update: 4/6/2005
				;---------------------------------------------------
 0000085F			.data
 0000085F 01			NoName  BYTE  NoNameCode
 00000EE5			.code
				        INVOKE WriteStackFrameName, numParam, numLocalVal, \
				               NumSavedReg, ADDR NoName
				                      ; NoNameCode
				                      ; Special signal that WriteStackFrameName
				                      ; is being called from WriteStackFrame
				        ret
 00000EFC			WriteStackFrame ENDP



				;--------------------------------------------------------
 00000EFC			WriteString PROC
				;
				; Writes a null-terminated string to standard
				; output. Input parameter: EDX points to the
				; string.
				; Last update: 9/7/01
				;--------------------------------------------------------
 00000EFC  60				pushad

					CheckInit
 00000EFD  80 3D 00000000 R  1		cmp InitFlag,0
	   00
 00000F04  75 05	     1		jne ??002C
 00000F06  E8 FFFFF614	     1		call Initialize
 00000F0B		     1	??002C:

					INVOKE Str_length,edx   	; return length of string in EAX
 00000F11  FC				cld	; must do this before WriteConsole

					INVOKE WriteConsole,
					    consoleOutHandle,     	; console output handle
					    edx,	; points to string
					    eax,	; string length
					    OFFSET bytesWritten,  	; returns number of bytes written
					    0

 00000F26  61				popad
 00000F27  C3				ret
 00000F28			WriteString ENDP


				;--------------------------------------------------------
 00000F28			WriteToFile PROC
				;
				; Writes a buffer to an output file.
				; Receives: EAX = file handle, EDX = buffer offset,
				;    ECX = number of bytes to write
				; Returns: EAX = number of bytes written to the file.
				; Last update: 6/8/2005
				;--------------------------------------------------------
 00000860			.data
 00000860 00000000		WriteToFile_1 DWORD ?    	; number of bytes written
 00000F28			.code
					INVOKE WriteFile,	; write buffer to file
						eax,	; file handle
						edx,	; buffer pointer
						ecx,	; number of bytes to write
						ADDR WriteToFile_1,	; number of bytes written
						0	; overlapped execution flag
 00000F37  A1 00000860 R		mov	eax,WriteToFile_1	; return value
 00000F3C  C3				ret
 00000F3D			WriteToFile ENDP


				;----------------------------------------------------
 00000F3D			WriteWindowsMsg PROC USES eax edx
				;
				; Displays a string containing the most recent error 
				; generated by MS-Windows.
				; Receives: nothing
				; Returns: nothing
				; Last updated: 6/10/05
				;----------------------------------------------------
 00000864			.data
 00000864 45 72 72 6F 72	WriteWindowsMsg_1 BYTE "Error ",0
	   20 00
 0000086B 3A 20 00		WriteWindowsMsg_2 BYTE ": ",0
 0000086E 00000000		pErrorMsg DWORD ?	; points to error message
 00000872 00000000		messageId DWORD ?
 00000F3F			.code
 00000F3F  E8 00000000 E		call	GetLastError
 00000F44  A3 00000872 R		mov	messageId,eax

				; Display the error number.
 00000F49  BA 00000864 R		mov	edx,OFFSET WriteWindowsMsg_1
 00000F4E  E8 FFFFFFA9			call	WriteString
 00000F53  E8 FFFFFCC9			call	WriteDec	; show error number
 00000F58  BA 0000086B R		mov	edx,OFFSET WriteWindowsMsg_2
 00000F5D  E8 FFFFFF9A			call	WriteString

				; Get the corresponding message string.
					INVOKE FormatMessage, FORMAT_MESSAGE_ALLOCATE_BUFFER + \
					  FORMAT_MESSAGE_FROM_SYSTEM, NULL, messageID, NULL,
					  ADDR pErrorMsg, NULL, NULL

				; Display the error message generated by MS-Windows.
 00000F7F  8B 15 0000086E R		mov	edx,pErrorMsg
 00000F85  E8 FFFFFF72			call	WriteString

				; Free the error message string.
					INVOKE LocalFree, pErrorMsg

					ret
 00000F98			WriteWindowsMsg ENDP


				;*************************************************************
				;*                    PRIVATE PROCEDURES                     *
				;*************************************************************

				; Convert AL to an ASCII digit. Used by WriteHex & WriteDec

 00000F98			AsciiDigit PROC PRIVATE
 00000F98  53				 push  ebx
 00000F99  BB 00000001 R		 mov   ebx,OFFSET xtable
 00000F9E  D7				 xlat
 00000F9F  5B				 pop   ebx
 00000FA0  C3				 ret
 00000FA1			AsciiDigit ENDP


 00000FA1			HexByte PROC PRIVATE
				; Display the byte in AL in hexadecimal

 00000FA1  60				pushad
 00000FA2  8A D0			mov  dl,al

 00000FA4  C0 C2 04			rol  dl,4
 00000FA7  8A C2			mov  al,dl
 00000FA9  24 0F			and  al,0Fh
 00000FAB  BB 00000001 R		mov  ebx,OFFSET xtable
 00000FB0  D7				xlat
 00000FB1  A2 00000061 R		mov  buffer,al	; save first char
 00000FB6  C0 C2 04			rol  dl,4
 00000FB9  8A C2			mov  al,dl
 00000FBB  24 0F			and  al,0Fh
 00000FBD  D7				xlat
 00000FBE  A2 00000062 R		mov  [buffer+1],al	; save second char
 00000FC3  C6 05 00000063 R		mov  [buffer+2],0	; null byte
	   00

 00000FCA  BA 00000061 R		mov  edx,OFFSET buffer	; display the buffer
 00000FCF  E8 FFFFFF28			call WriteString

 00000FD4  61				popad
 00000FD5  C3				ret
 00000FD6			HexByte ENDP

				END

				;****************************************************************
				;                            ARCHIVE AREA
				;
				; The following code has been 'retired', but may still be useful
				; as a reference.
				;****************************************************************


				;------------------------------------------------------------
				ReadChar PROC
				;
				; Retired 7/5/05
				;
				; Reads one character from the keyboard. The character is
				; not echoed on the screen. Waits for the character if none is
				; currently in the input buffer.
				; Returns:  AL = ASCII code
				;----------------------------------------------------------
					push ebx
					push eax

				L1:	mov  eax,10	; give Windows 10ms to process messages
					call Delay
					call ReadKey	; look for key in buffer
					jz   L1	; no key in buffer if ZF=1

					; Special epilogue code used here to return AL, yet 
					; preserve the high 24 bits of EAX.
					mov  bl,al	; save ASCII code
					pop  eax
					mov  al,bl
					pop  ebx
					ret
				ReadChar ENDP


				;--------------------------------------------------------
				ReadDec PROC USES ebx ecx edx esi
				  LOCAL saveDigit:DWORD
				;
				; Retired 7/15/05
				;
				; Reads a 32-bit unsigned decimal integer from the keyboard,
				; stopping when the Enter key is pressed.All valid digits occurring 
				; before a non-numeric character are converted to the integer value. 
				; Leading spaces are ignored.

				; Receives: nothing
				; Returns:
				;  If the integer is blank, EAX=0 and CF=1
				;  If the integer contains only spaces, EAX=0 and CF=1
				;  If the integer is larger than 2^32-1, EAX=0 and CF=1
				;  Otherwise, EAX=converted integer, and CF=0
				;
				; Last update: 11/11/02
				;--------------------------------------------------------
				; Input a string of digits using ReadString.

					mov   edx,OFFSET digitBuffer
					mov   esi,edx           		; save offset in ESI
					mov   ecx,MAX_DIGITS
					call  ReadString
					mov   ecx,eax           		; save length in CX
					cmp   ecx,0            		; greater than zero?
					jne   L1              		; yes: continue
					mov   eax,0            		; no: set return value
					jmp   L5              		; and exit with CF=1

				; Skip over any leading spaces.

				L1:	mov   al,[esi]         		; get a character from buffer
					cmp   al,' '          		; space character found?
					jne   L2              		; no: goto next step
					inc   esi              		; yes: point to next char
					loop  L1		; all spaces?
					jmp   L5		; yes: exit with CF=1

				; Start to convert the number.

				L2:	mov  eax,0           		; clear accumulator
					mov  ebx,10          		; EBX is the divisor

				; Repeat loop for each digit.

				L3:	mov  dl,[esi]		; get character from buffer
					cmp  dl,'0'		; character < '0'?
					jb   L4
					cmp  dl,'9'		; character > '9'?
					ja   L4
					and  edx,0Fh		; no: convert to binary

					mov  saveDigit,edx
					mul  ebx		; EDX:EAX = EAX * EBX
					jc   L5		; quit if Carry (EDX > 0)
					mov  edx,saveDigit
					add  eax,edx         		; add new digit to sum
					jc   L5		; quit if Carry generated
					inc  esi              		; point to next digit
					jmp  L3		; get next digit

				L4:	clc	; succesful completion (CF=0)
					jmp  L6

				L5: mov  eax,0	; clear result to zero
					stc	; signal an error (CF=1)
				L6:
					ret
				ReadDec ENDP


				;--------------------------------------------------------
				ReadFromFile PROC
				;
				; Retired 7/6/05
				;
				; Reads an input file into a buffer. 
				; Receives: EAX = file handle, EDX = buffer offset,
				;    ECX = number of bytes to read
				; Returns: EAX = number of bytes read.
				; Last update: 6/8/2005
				;--------------------------------------------------------
				.data
				ReadFromFile_1 DWORD ?    	; number of bytes read
				.code
					INVOKE ReadFile,
					    eax,	; file handle
					    edx,	; buffer pointer
					    ecx,	; max bytes to read
					    ADDR ReadFromFile_1,	; number of bytes read
					    0		; overlapped execution flag
					mov	eax,ReadFromFile_1
					ret
				ReadFromFile ENDP


				;--------------------------------------------------------
				ReadInt PROC USES ebx ecx edx esi
				  LOCAL Lsign:SDWORD, saveDigit:DWORD
				;
				; Retired 7/15/05
				;
				; Reads a 32-bit signed decimal integer from standard
				; input, stopping when the Enter key is pressed.
				; All valid digits occurring before a non-numeric character
				; are converted to the integer value. Leading spaces are
				; ignored, and an optional leading + or - sign is permitted.
				; All spaces return a valid integer, value zero.

				; Receives: nothing
				; Returns:  If CF=0, the integer is valid, and EAX = binary value.
				;   If CF=1, the integer is invalid and EAX = 0.
				;
				; Contains corrections by Gerald Cahill
				; Updated: 10/10/2003
				;--------------------------------------------------------
				.data
				overflow_msgL BYTE  " <32-bit integer overflow>",0
				invalid_msgL  BYTE  " <invalid integer>",0
				;allspace_msgL BYTE  " <all spaces input>",0 
				.code

				; Input a string of digits using ReadString.

				        mov   Lsign,1                   ; assume number is positive
				        mov   edx,OFFSET digitBuffer
				        mov   esi,edx                   ; save offset in SI
				        mov   ecx,MAX_DIGITS
				        call  ReadString
				        mov   ecx,eax                   ; save length in ECX
				        cmp   ecx,0                     ; length greater than zero?
				        jne   L1                        ; yes: continue
				        mov   eax,0                     ; no: set return value
				        jmp   L10                       ; and exit

				; Skip over any leading spaces.

				L1:     mov   al,[esi]                  ; get a character from buffer
				        cmp   al,' '                    ; space character found?
				        jne   L2                        ; no: check for a sign
				        inc   esi                       ; yes: point to next char
				        loop  L1
				        mov   eax,0		 ; all spaces?
				        jmp   L10		 ; return zero as valid value
				;       mov   edx,OFFSET allspace_msgL    (line removed)
				;       jcxz  L8                          (line removed)

				; Check for a leading sign.

				L2:     cmp   al,'-'                    ; minus sign found?
				        jne   L3                        ; no: look for plus sign

				        mov   Lsign,-1                  ; yes: sign is negative
				        dec   ecx                       ; subtract from counter
				        inc   esi                       ; point to next char
				        jmp   L3A

				L3:     cmp   al,'+'                    ; plus sign found?
				        jne   L3A               			; no: skip
				        inc   esi                       ; yes: move past the sign
				        dec   ecx                       ; subtract from digit counter

				; Test the first digit, and exit if nonnumeric.

				L3A:mov  al,[esi]               		; get first character
				        call IsDigit            		; is it a digit?
				        jnz  L7A                		; no: show error message

				; Start to convert the number.

				L4:     mov   eax,0                     ; clear accumulator
				        mov   ebx,10                    ; EBX is the divisor

				; Repeat loop for each digit.

				L5:     mov  dl,[esi]           ; get character from buffer
				        cmp  dl,'0'             ; character < '0'?
				        jb   L9
				        cmp  dl,'9'             ; character > '9'?
				        ja   L9
				        and  edx,0Fh            ; no: convert to binary

				        mov  saveDigit,edx
				        imul ebx                ; EDX:EAX = EAX * EBX
				        mov  edx,saveDigit

				        jo   L6                 ; quit if overflow
				        add  eax,edx            ; add new digit to AX
				        jo   L6                 ; quit if overflow
				        inc  esi                ; point to next digit
				        jmp  L5                 ; get next digit

				; Overflow has occured, unlesss EAX = 80000000h
				; and the sign is negative:

				L6: cmp  eax,80000000h
				    jne  L7
				    cmp  Lsign,-1
				    jne  L7                 ; overflow occurred
				    jmp  L9                 ; the integer is valid

				; Choose "integer overflow" messsage.

				L7: mov  edx,OFFSET overflow_msgL
				    jmp  L8

				; Choose "invalid integer" message.

				L7A:
				    mov  edx,OFFSET invalid_msgL

				; Display the error message pointed to by EDX, and set the Overflow flag.

				L8:	call WriteString
				    call Crlf
				    mov al,127
				    add al,1                ; set Overflow flag
				    mov  eax,0              ; set return value to zero
				    jmp  L10                ; and exit

				; IMUL leaves the Sign flag in an undeterminate state, so the OR instruction
				; determines the sign of the iteger in EAX.
				L9:	imul Lsign                  ; EAX = EAX * sign
				    or eax,eax              ; determine the number's Sign

				L10:ret
				ReadInt ENDP

Microsoft (R) Macro Assembler Version 6.15.8803		    07/25/05 00:49:42
Irvine32 Link Library Source Code         (Irvine32.asm)     Symbols 2 - 1




Macros:

                N a m e                 Type

CheckInit  . . . . . . . . . . .	Proc
IsDefined  . . . . . . . . . . .	Func
ShowFlag . . . . . . . . . . . .	Proc
Startup  . . . . . . . . . . . .	Proc
mDumpMem . . . . . . . . . . . .	Proc
mDump  . . . . . . . . . . . . .	Proc
mGotoxy  . . . . . . . . . . . .	Proc
mReadString  . . . . . . . . . .	Proc
mShowRegister  . . . . . . . . .	Proc
mShow  . . . . . . . . . . . . .	Proc
mWriteSpace  . . . . . . . . . .	Proc
mWriteString . . . . . . . . . .	Proc
mWrite . . . . . . . . . . . . .	Proc


Structures and Unions:

                N a m e                  Size
                                         Offset      Type

CONSOLE_CURSOR_INFO  . . . . . .	 00000008
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  bVisible . . . . . . . . . . .	 00000004	 DWord
CONSOLE_SCREEN_BUFFER_INFO . . .	 00000016
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  dwCursorPosition . . . . . . .	 00000004	 DWord
  wAttributes  . . . . . . . . .	 00000008	 Word
  srWindow . . . . . . . . . . .	 0000000A	 QWord
  dwMaximumWindowSize  . . . . .	 00000012	 DWord
COORD  . . . . . . . . . . . . .	 00000004
  X  . . . . . . . . . . . . . .	 00000000	 Word
  Y  . . . . . . . . . . . . . .	 00000002	 Word
FILETIME . . . . . . . . . . . .	 00000008
  loDateTime . . . . . . . . . .	 00000000	 DWord
  hiDateTime . . . . . . . . . .	 00000004	 DWord
FOCUS_EVENT_RECORD . . . . . . .	 00000004
  bSetFocus  . . . . . . . . . .	 00000000	 DWord
INPUT_RECORD . . . . . . . . . .	 00000014
  EventType  . . . . . . . . . .	 00000000	 Word
  Event  . . . . . . . . . . . .	 00000004	  00000010
  bKeyDown . . . . . . . . . . .	 00000000	 DWord
  wRepeatCount . . . . . . . . .	 00000004	 Word
  wVirtualKeyCode  . . . . . . .	 00000006	 Word
  wVirtualScanCode . . . . . . .	 00000008	 Word
  uChar  . . . . . . . . . . . .	 0000000A	 Word
  UnicodeChar  . . . . . . . . .	 00000000	 Word
  AsciiChar  . . . . . . . . . .	 00000000	 Byte
  dwControlKeyState  . . . . . .	 0000000C	 DWord
  dwMousePosition  . . . . . . .	 00000000	 DWord
  dwButtonState  . . . . . . . .	 00000004	 DWord
  dwMouseControlKeyState . . . .	 00000008	 DWord
  dwEventFlags . . . . . . . . .	 0000000C	 DWord
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  dwCommandId  . . . . . . . . .	 00000000	 DWord
  bSetFocus  . . . . . . . . . .	 00000000	 DWord
KEY_EVENT_RECORD . . . . . . . .	 00000010
  bKeyDown . . . . . . . . . . .	 00000000	 DWord
  wRepeatCount . . . . . . . . .	 00000004	 Word
  wVirtualKeyCode  . . . . . . .	 00000006	 Word
  wVirtualScanCode . . . . . . .	 00000008	 Word
  uChar  . . . . . . . . . . . .	 0000000A	 Word
  UnicodeChar  . . . . . . . . .	 00000000	 Word
  AsciiChar  . . . . . . . . . .	 00000000	 Byte
  dwControlKeyState  . . . . . .	 0000000C	 DWord
MENU_EVENT_RECORD  . . . . . . .	 00000004
  dwCommandId  . . . . . . . . .	 00000000	 DWord
MOUSE_EVENT_RECORD . . . . . . .	 00000010
  dwMousePosition  . . . . . . .	 00000000	 DWord
  dwButtonState  . . . . . . . .	 00000004	 DWord
  dwMouseControlKeyState . . . .	 00000008	 DWord
  dwEventFlags . . . . . . . . .	 0000000C	 DWord
SMALL_RECT . . . . . . . . . . .	 00000008
  Left . . . . . . . . . . . . .	 00000000	 Word
  Top  . . . . . . . . . . . . .	 00000002	 Word
  Right  . . . . . . . . . . . .	 00000004	 Word
  Bottom . . . . . . . . . . . .	 00000006	 Word
SYSTEMTIME . . . . . . . . . . .	 00000010
  wYear  . . . . . . . . . . . .	 00000000	 Word
  wMonth . . . . . . . . . . . .	 00000002	 Word
  wDayOfWeek . . . . . . . . . .	 00000004	 Word
  wDay . . . . . . . . . . . . .	 00000006	 Word
  wHour  . . . . . . . . . . . .	 00000008	 Word
  wMinute  . . . . . . . . . . .	 0000000A	 Word
  wSecond  . . . . . . . . . . .	 0000000C	 Word
  wMilliseconds  . . . . . . . .	 0000000E	 Word
WINDOW_BUFFER_SIZE_RECORD  . . .	 00000004
  dwSize . . . . . . . . . . . .	 00000000	 DWord


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .	GROUP
STACK  . . . . . . . . . . . . .	32 Bit	 00001000 Para	  Stack	  'STACK'	 
_BSS . . . . . . . . . . . . . .	32 Bit	 00000275 Para	  Public  'BSS'  
_DATA  . . . . . . . . . . . . .	32 Bit	 00000876 Para	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 00000FD6 Para	  Public  'CODE'	


Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

AsciiDigit . . . . . . . . . . .	P Near	 00000F98 _TEXT	Length= 00000009 Private STDCALL
CloseFile  . . . . . . . . . . .	P Near	 00000000 _TEXT	Length= 00000007 Public STDCALL
CloseHandle  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Clrscr . . . . . . . . . . . . .	P Near	 00000007 _TEXT	Length= 000000C5 Public STDCALL
  bufInfo  . . . . . . . . . . .	 00000016    bp - 00000016
  ??0000 . . . . . . . . . . . .	L Near	 0000001C _TEXT	
  L1 . . . . . . . . . . . . . .	L Near	 00000061 _TEXT	
CreateFileA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateOutputFile . . . . . . . .	P Near	 000000CC _TEXT	Length= 00000019 Public STDCALL
Crlf . . . . . . . . . . . . . .	P Near	 000000E5 _TEXT	Length= 0000001B Public STDCALL
  ??0001 . . . . . . . . . . . .	L Near	 000000F3 _TEXT	
Delay  . . . . . . . . . . . . .	P Near	 00000100 _TEXT	Length= 00000009 Public STDCALL
DumpMem  . . . . . . . . . . . .	P Near	 00000109 _TEXT	Length= 000000BB Public STDCALL
  unitsize . . . . . . . . . . .	DWord	 bp - 00000004
  byteCount  . . . . . . . . . .	Word	 bp - 00000006
  L1 . . . . . . . . . . . . . .	L Near	 00000145 _TEXT	
  L2 . . . . . . . . . . . . . .	L Near	 0000015E _TEXT	
  L3 . . . . . . . . . . . . . .	L Near	 00000186 _TEXT	
  L3B  . . . . . . . . . . . . .	L Near	 000001B8 _TEXT	
  L4 . . . . . . . . . . . . . .	L Near	 000001BC _TEXT	
DumpRegs . . . . . . . . . . . .	P Near	 000001C4 _TEXT	Length= 000001FB Public STDCALL
  ??0012 . . . . . . . . . . . .	L Near	 000002E8 _TEXT	
  ??0015 . . . . . . . . . . . .	L Near	 0000030E _TEXT	
  ??0018 . . . . . . . . . . . .	L Near	 00000334 _TEXT	
  ??001B . . . . . . . . . . . .	L Near	 0000035A _TEXT	
  ??001E . . . . . . . . . . . .	L Near	 00000380 _TEXT	
  ??0021 . . . . . . . . . . . .	L Near	 000003A6 _TEXT	
ExitProcess  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FileTimeToDosDateTime  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FileTimeToSystemTime . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FlushConsoleInputBuffer  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FormatMessageA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCommandLineA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCommandTail . . . . . . . . .	P Near	 000003BF _TEXT	Length= 00000035 Public STDCALL
  L0 . . . . . . . . . . . . . .	L Near	 000003CA _TEXT	
  LB . . . . . . . . . . . . . .	L Near	 000003E2 _TEXT	
  L1 . . . . . . . . . . . . . .	L Near	 000003E7 _TEXT	
  L2 . . . . . . . . . . . . . .	L Near	 000003F2 _TEXT	
GetConsoleCP . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleCursorInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleMode . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleScreenBufferInfo . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDateTime  . . . . . . . . . .	P Near	 000003FC _TEXT	Length= 00000032 Public STDCALL
  pDateTime  . . . . . . . . . .	DWord	 bp + 00000008
  flTime . . . . . . . . . . . .	QWord	 bp - 00000008
GetFileTime  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetKeyState  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLastError . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLocalTime . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMaxXY . . . . . . . . . . . .	P Near	 0000042E _TEXT	Length= 00000033 Public STDCALL
  bufInfo  . . . . . . . . . . .	 00000016    bp - 00000016
  ??0022 . . . . . . . . . . . .	L Near	 00000443 _TEXT	
GetMseconds  . . . . . . . . . .	P Near	 00000461 _TEXT	Length= 0000005D Public STDCALL
  hours  . . . . . . . . . . . .	DWord	 bp - 00000004
  min  . . . . . . . . . . . . .	DWord	 bp - 00000008
  sec  . . . . . . . . . . . . .	DWord	 bp - 0000000C
GetNumberOfConsoleInputEvents  .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProcessHeap . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetStdHandle . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSystemTime  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTextColor . . . . . . . . . .	P Near	 000004BE _TEXT	Length= 0000002B Public STDCALL
  bufInfo  . . . . . . . . . . .	 00000016    bp - 00000016
  ??0023 . . . . . . . . . . . .	L Near	 000004D3 _TEXT	
GetTickCount . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Gotoxy . . . . . . . . . . . . .	P Near	 000004E9 _TEXT	Length= 00000036 Public STDCALL
  ??0024 . . . . . . . . . . . .	L Near	 000004F8 _TEXT	
HeapAlloc  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapCreate . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapDestroy  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapFree . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapSize . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HexByte  . . . . . . . . . . . .	P Near	 00000FA1 _TEXT	Length= 00000035 Private STDCALL
Initialize . . . . . . . . . . .	P Near	 0000051F _TEXT	Length= 00000022 Private STDCALL
IsDigit  . . . . . . . . . . . .	P Near	 00000541 _TEXT	Length= 0000000D Public STDCALL
  ID1  . . . . . . . . . . . . .	L Near	 0000054D _TEXT	
LocalFree  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MessageBoxA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MsgBoxAsk  . . . . . . . . . . .	P Near	 00000565 _TEXT	Length= 0000001F Public STDCALL
MsgBox . . . . . . . . . . . . .	P Near	 0000054E _TEXT	Length= 00000017 Public STDCALL
OpenInputFile  . . . . . . . . .	P Near	 00000584 _TEXT	Length= 00000019 Public STDCALL
ParseDecimal32 . . . . . . . . .	P Near	 0000059D _TEXT	Length= 00000062 Public STDCALL
  saveDigit  . . . . . . . . . .	DWord	 bp - 00000004
  L1 . . . . . . . . . . . . . .	L Near	 000005B5 _TEXT	
  L1A  . . . . . . . . . . . . .	L Near	 000005C1 _TEXT	
  L2 . . . . . . . . . . . . . .	L Near	 000005C6 _TEXT	
  L3 . . . . . . . . . . . . . .	L Near	 000005D0 _TEXT	
  L4 . . . . . . . . . . . . . .	L Near	 000005F0 _TEXT	
  L5 . . . . . . . . . . . . . .	L Near	 000005F3 _TEXT	
  L6 . . . . . . . . . . . . . .	L Near	 000005F9 _TEXT	
ParseInteger32 . . . . . . . . .	P Near	 000005FF _TEXT	Length= 000000BB Public STDCALL
  Lsign  . . . . . . . . . . . .	DWord	 bp - 00000004
  saveDigit  . . . . . . . . . .	DWord	 bp - 00000008
  L1 . . . . . . . . . . . . . .	L Near	 00000621 _TEXT	
  L1A  . . . . . . . . . . . . .	L Near	 0000062D _TEXT	
  L2 . . . . . . . . . . . . . .	L Near	 00000637 _TEXT	
  L3 . . . . . . . . . . . . . .	L Near	 00000646 _TEXT	
  L3A  . . . . . . . . . . . . .	L Near	 0000064C _TEXT	
  L4 . . . . . . . . . . . . . .	L Near	 00000655 _TEXT	
  L5 . . . . . . . . . . . . . .	L Near	 0000065F _TEXT	
  L6 . . . . . . . . . . . . . .	L Near	 0000067F _TEXT	
  L7 . . . . . . . . . . . . . .	L Near	 0000068E _TEXT	
  L7A  . . . . . . . . . . . . .	L Near	 00000695 _TEXT	
  L8 . . . . . . . . . . . . . .	L Near	 0000069A _TEXT	
  L9 . . . . . . . . . . . . . .	L Near	 000006AF _TEXT	
  L10  . . . . . . . . . . . . .	L Near	 000006B4 _TEXT	
PeekConsoleInputA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Random32 . . . . . . . . . . . .	P Near	 000006BA _TEXT	Length= 0000001B Public STDCALL
RandomRange  . . . . . . . . . .	P Near	 000006D5 _TEXT	Length= 00000015 Public STDCALL
Randomize  . . . . . . . . . . .	P Near	 000006EA _TEXT	Length= 00000019 Public STDCALL
ReadChar . . . . . . . . . . . .	P Near	 00000703 _TEXT	Length= 00000016 Public STDCALL
  L1 . . . . . . . . . . . . . .	L Near	 00000705 _TEXT	
ReadConsoleA . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleInputA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadDec  . . . . . . . . . . . .	P Near	 00000719 _TEXT	Length= 0000001B Public STDCALL
ReadFile . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFloat  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFromFile . . . . . . . . . .	P Near	 00000734 _TEXT	Length= 00000023 Public STDCALL
  L1 . . . . . . . . . . . . . .	L Near	 00000750 _TEXT	
  L2 . . . . . . . . . . . . . .	L Near	 00000756 _TEXT	
ReadHex  . . . . . . . . . . . .	P Near	 00000757 _TEXT	Length= 00000081 Public STDCALL
  B1 . . . . . . . . . . . . . .	L Near	 00000775 _TEXT	
  B1A  . . . . . . . . . . . . .	L Near	 00000781 _TEXT	
  B4 . . . . . . . . . . . . . .	L Near	 00000786 _TEXT	
  B5 . . . . . . . . . . . . . .	L Near	 00000795 _TEXT	
  B6 . . . . . . . . . . . . . .	L Near	 0000079D _TEXT	
  B7 . . . . . . . . . . . . . .	L Near	 000007C5 _TEXT	
  B8 . . . . . . . . . . . . . .	L Near	 000007CD _TEXT	
  B9 . . . . . . . . . . . . . .	L Near	 000007D3 _TEXT	
ReadInt  . . . . . . . . . . . .	P Near	 000007D8 _TEXT	Length= 0000001B Public STDCALL
ReadKeyFlush . . . . . . . . . .	P Near	 0000090E _TEXT	Length= 00000015 Public STDCALL
ReadKeyTranslate . . . . . . . .	P Near	 00000923 _TEXT	Length= 000000B9 Private STDCALL
  Search . . . . . . . . . . . .	L Near	 0000092D _TEXT	
  Found  . . . . . . . . . . . .	L Near	 00000946 _TEXT	
  NotFound . . . . . . . . . . .	L Near	 00000972 _TEXT	
  Done . . . . . . . . . . . . .	L Near	 000009D6 _TEXT	
ReadKey  . . . . . . . . . . . .	P Near	 000007F3 _TEXT	Length= 0000011B Public STDCALL
  evEvents . . . . . . . . . . .	DWord	 bp - 00000004
  saveFlags  . . . . . . . . . .	DWord	 bp - 00000008
  ??0025 . . . . . . . . . . . .	L Near	 00000808 _TEXT	
  Peek . . . . . . . . . . . . .	L Near	 0000082E _TEXT	
  HaveKey  . . . . . . . . . . .	L Near	 00000892 _TEXT	
  NoKey  . . . . . . . . . . . .	L Near	 000008E6 _TEXT	
  Done . . . . . . . . . . . . .	L Near	 000008F4 _TEXT	
ReadString . . . . . . . . . . .	P Near	 000009DC _TEXT	Length= 000000B9 Public STDCALL
  bufSize  . . . . . . . . . . .	DWord	 bp - 00000004
  saveFlags  . . . . . . . . . .	DWord	 bp - 00000008
  junk . . . . . . . . . . . . .	DWord	 bp - 0000000C
  ??0026 . . . . . . . . . . . .	L Near	 000009F1 _TEXT	
  L1 . . . . . . . . . . . . . .	L Near	 00000A36 _TEXT	
  L6 . . . . . . . . . . . . . .	L Near	 00000A5B _TEXT	
  L2 . . . . . . . . . . . . . .	L Near	 00000A8A _TEXT	
  L5 . . . . . . . . . . . . . .	L Near	 00000A8D _TEXT	
SetConsoleCursorInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleCursorPosition . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleMode . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleScreenBufferSize . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleTextAttribute  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleTitleA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleWindowInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetFilePointer . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetLocalTime . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetTextColor . . . . . . . . . .	P Near	 00000A95 _TEXT	Length= 00000021 Public STDCALL
  ??0027 . . . . . . . . . . . .	L Near	 00000AA4 _TEXT	
ShowFPUStack . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Sleep  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
StrLength  . . . . . . . . . . .	P Near	 00000AB6 _TEXT	Length= 00000011 Public STDCALL
  L1 . . . . . . . . . . . . . .	L Near	 00000ABC _TEXT	
  L2 . . . . . . . . . . . . . .	L Near	 00000AC5 _TEXT	
Str_compare  . . . . . . . . . .	P Near	 00000AC7 _TEXT	Length= 0000002A Public STDCALL
  string1  . . . . . . . . . . .	DWord	 bp + 00000008
  string2  . . . . . . . . . . .	DWord	 bp + 0000000C
  L1 . . . . . . . . . . . . . .	L Near	 00000AD4 _TEXT	
  L2 . . . . . . . . . . . . . .	L Near	 00000AE3 _TEXT	
  L3 . . . . . . . . . . . . . .	L Near	 00000AE9 _TEXT	
Str_copy . . . . . . . . . . . .	P Near	 00000AF1 _TEXT	Length= 00000023 Public STDCALL
  source . . . . . . . . . . . .	DWord	 bp + 00000008
  target . . . . . . . . . . . .	DWord	 bp + 0000000C
Str_length . . . . . . . . . . .	P Near	 00000B14 _TEXT	Length= 0000001A Public STDCALL
  pString  . . . . . . . . . . .	DWord	 bp + 00000008
  L1 . . . . . . . . . . . . . .	L Near	 00000B20 _TEXT	
  L2 . . . . . . . . . . . . . .	L Near	 00000B29 _TEXT	
Str_trim . . . . . . . . . . . .	P Near	 00000B2E _TEXT	Length= 0000002D Public STDCALL
  pString  . . . . . . . . . . .	DWord	 bp + 00000008
  char . . . . . . . . . . . . .	Byte	 bp + 0000000C
  L1 . . . . . . . . . . . . . .	L Near	 00000B50 _TEXT	
  L2 . . . . . . . . . . . . . .	L Near	 00000B54 _TEXT	
Str_ucase  . . . . . . . . . . .	P Near	 00000B5B _TEXT	Length= 00000022 Public STDCALL
  pString  . . . . . . . . . . .	DWord	 bp + 00000008
  L1 . . . . . . . . . . . . . .	L Near	 00000B63 _TEXT	
  L2 . . . . . . . . . . . . . .	L Near	 00000B74 _TEXT	
  L3 . . . . . . . . . . . . . .	L Near	 00000B77 _TEXT	
SystemTimeToFileTime . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WaitMsg  . . . . . . . . . . . .	P Near	 00000B7D _TEXT	Length= 00000012 Public STDCALL
WriteBinB  . . . . . . . . . . .	P Near	 00000B9C _TEXT	Length= 00000053 Public STDCALL
  WB0  . . . . . . . . . . . . .	L Near	 00000BAC _TEXT	
  WB0A . . . . . . . . . . . . .	L Near	 00000BC0 _TEXT	
  WB1  . . . . . . . . . . . . .	L Near	 00000BC5 _TEXT	
  WB1A . . . . . . . . . . . . .	L Near	 00000BCB _TEXT	
  WB2  . . . . . . . . . . . . .	L Near	 00000BD5 _TEXT	
WriteBin . . . . . . . . . . . .	P Near	 00000B8F _TEXT	Length= 0000000D Public STDCALL
WriteChar  . . . . . . . . . . .	P Near	 00000BEF _TEXT	Length= 00000032 Public STDCALL
  ??0028 . . . . . . . . . . . .	L Near	 00000BFF _TEXT	
WriteConsoleA  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleOutputAttribute  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleOutputCharacterA . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteDec . . . . . . . . . . . .	P Near	 00000C21 _TEXT	Length= 00000041 Public STDCALL
  ??0029 . . . . . . . . . . . .	L Near	 00000C30 _TEXT	
  WI1  . . . . . . . . . . . . .	L Near	 00000C42 _TEXT	
  WI3  . . . . . . . . . . . . .	L Near	 00000C58 _TEXT	
  WI4  . . . . . . . . . . . . .	L Near	 00000C60 _TEXT	
WriteFile  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteFloat . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteHexB  . . . . . . . . . . .	P Near	 00000C6F _TEXT	Length= 00000092 Public STDCALL
  displaySize  . . . . . . . . .	DWord	 bp - 00000004
  ??002A . . . . . . . . . . . .	L Near	 00000CA6 _TEXT	
  L1 . . . . . . . . . . . . . .	L Near	 00000CBD _TEXT	
  L2 . . . . . . . . . . . . . .	L Near	 00000CE2 _TEXT	
  L3 . . . . . . . . . . . . . .	L Near	 00000CEC _TEXT	
WriteHex . . . . . . . . . . . .	P Near	 00000C62 _TEXT	Length= 0000000D Public STDCALL
WriteInt . . . . . . . . . . . .	P Near	 00000D01 _TEXT	Length= 00000061 Public STDCALL
  ??002B . . . . . . . . . . . .	L Near	 00000D10 _TEXT	
  WIS1 . . . . . . . . . . . . .	L Near	 00000D24 _TEXT	
  WIS2 . . . . . . . . . . . . .	L Near	 00000D36 _TEXT	
  WIS3 . . . . . . . . . . . . .	L Near	 00000D59 _TEXT	
WriteStackFrameName  . . . . . .	P Near	 00000D62 _TEXT	Length= 00000180 Public STDCALL
  numParam . . . . . . . . . . .	DWord	 bp + 00000008
  numLocalVal  . . . . . . . . .	DWord	 bp + 0000000C
  numSavedReg  . . . . . . . . .	DWord	 bp + 00000010
  procName . . . . . . . . . . .	DWord	 bp + 00000014
  theReturn  . . . . . . . . . .	DWord	 bp - 00000004
  theBase  . . . . . . . . . . .	DWord	 bp - 00000008
  firstLocal . . . . . . . . . .	DWord	 bp - 0000000C
  firstSaved . . . . . . . . . .	DWord	 bp - 00000010
  specialFirstSaved  . . . . . .	DWord	 bp - 00000014
  L0 . . . . . . . . . . . . . .	L Near	 00000D96 _TEXT	
  Normal . . . . . . . . . . . .	L Near	 00000DC2 _TEXT	
  Special  . . . . . . . . . . .	L Near	 00000DF1 _TEXT	
  L0z  . . . . . . . . . . . . .	L Near	 00000E17 _TEXT	
  L0a  . . . . . . . . . . . . .	L Near	 00000E1A _TEXT	
  L0b  . . . . . . . . . . . . .	L Near	 00000E1D _TEXT	
  L0c  . . . . . . . . . . . . .	L Near	 00000E24 _TEXT	
  L0e  . . . . . . . . . . . . .	L Near	 00000E40 _TEXT	
  L1 . . . . . . . . . . . . . .	L Near	 00000E42 _TEXT	
  L2 . . . . . . . . . . . . . .	L Near	 00000E66 _TEXT	
  L2a  . . . . . . . . . . . . .	L Near	 00000E72 _TEXT	
  L3 . . . . . . . . . . . . . .	L Near	 00000E7E _TEXT	
  L4 . . . . . . . . . . . . . .	L Near	 00000E8A _TEXT	
  L5 . . . . . . . . . . . . . .	L Near	 00000E96 _TEXT	
  LPrint . . . . . . . . . . . .	L Near	 00000E9B _TEXT	
  LDone  . . . . . . . . . . . .	L Near	 00000EAF _TEXT	
  LDoneX . . . . . . . . . . . .	L Near	 00000EBE _TEXT	
  Return . . . . . . . . . . . .	L Near	 00000EC0 _TEXT	
  BadStackFrame  . . . . . . . .	L Near	 00000EC9 _TEXT	
WriteStackFrame  . . . . . . . .	P Near	 00000EE2 _TEXT	Length= 0000001A Public STDCALL
  numParam . . . . . . . . . . .	DWord	 bp + 00000008
  numLocalVal  . . . . . . . . .	DWord	 bp + 0000000C
  numSavedReg  . . . . . . . . .	DWord	 bp + 00000010
WriteString  . . . . . . . . . .	P Near	 00000EFC _TEXT	Length= 0000002C Public STDCALL
  ??002C . . . . . . . . . . . .	L Near	 00000F0B _TEXT	
WriteToFile  . . . . . . . . . .	P Near	 00000F28 _TEXT	Length= 00000015 Public STDCALL
WriteWindowsMsg  . . . . . . . .	P Near	 00000F3D _TEXT	Length= 0000005B Public STDCALL
printf . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C
scan_for_quote . . . . . . . . .	P Near	 000003F4 _TEXT	Length= 00000008 Private STDCALL
  L0 . . . . . . . . . . . . . .	L Near	 000003F4 _TEXT	
scanf  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C
wsprintfA  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C


Symbols:

                N a m e                 Type     Value    Attr

??0002 . . . . . . . . . . . . .	Byte	 0000061D _DATA	
??0003 . . . . . . . . . . . . .	Byte	 00000656 _DATA	
??0004 . . . . . . . . . . . . .	Byte	 00000659 _DATA	
??0005 . . . . . . . . . . . . .	Byte	 0000065B _DATA	
??0006 . . . . . . . . . . . . .	Byte	 00000665 _DATA	
??0007 . . . . . . . . . . . . .	Byte	 0000066C _DATA	
??0008 . . . . . . . . . . . . .	Byte	 00000673 _DATA	
??0009 . . . . . . . . . . . . .	Byte	 0000067A _DATA	
??000A . . . . . . . . . . . . .	Byte	 00000681 _DATA	
??000B . . . . . . . . . . . . .	Byte	 00000688 _DATA	
??000C . . . . . . . . . . . . .	Byte	 0000068F _DATA	
??000D . . . . . . . . . . . . .	Byte	 00000696 _DATA	
??000E . . . . . . . . . . . . .	Byte	 0000069D _DATA	
??000F . . . . . . . . . . . . .	Byte	 000006A4 _DATA	
??0010 . . . . . . . . . . . . .	Byte	 000006AB _DATA	
??0011 . . . . . . . . . . . . .	Byte	 000006B0 _DATA	
??0013 . . . . . . . . . . . . .	Byte	 000006B2 _DATA	
??0014 . . . . . . . . . . . . .	Byte	 000006B7 _DATA	
??0016 . . . . . . . . . . . . .	Byte	 000006B9 _DATA	
??0017 . . . . . . . . . . . . .	Byte	 000006BE _DATA	
??0019 . . . . . . . . . . . . .	Byte	 000006C0 _DATA	
??001A . . . . . . . . . . . . .	Byte	 000006C5 _DATA	
??001C . . . . . . . . . . . . .	Byte	 000006C7 _DATA	
??001D . . . . . . . . . . . . .	Byte	 000006CC _DATA	
??001F . . . . . . . . . . . . .	Byte	 000006CE _DATA	
??0020 . . . . . . . . . . . . .	Byte	 000006D3 _DATA	
@CodeSize  . . . . . . . . . . .	Number	 00000000h   
@DataSize  . . . . . . . . . . .	Number	 00000000h   
@Interface . . . . . . . . . . .	Number	 00000003h   
@Model . . . . . . . . . . . . .	Number	 00000007h   
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 FLAT
@fardata?  . . . . . . . . . . .	Text   	 FLAT
@fardata . . . . . . . . . . . .	Text   	 FLAT
@stack . . . . . . . . . . . . .	Text   	 FLAT
@zq02abc_def_caption . . . . . .	Byte	 000006DB _DATA	
@zx02abc_def_caption . . . . . .	Byte	 000006D9 _DATA	
ALT_MASK . . . . . . . . . . . .	Number	 00000003h   
BadStackFrameMsg . . . . . . . .	Byte	 00000844 _DATA	
CAPSLOCK_ON  . . . . . . . . . .	Number	 00000080h   
CREATE_ALWAYS  . . . . . . . . .	Number	 00000002h   
CREATE_NEW . . . . . . . . . . .	Number	 00000001h   
CTRL_MASK  . . . . . . . . . . .	Number	 0000000Ch   
CaseSize . . . . . . . . . . . .	Number	 00000004h   
CreateFile . . . . . . . . . . .	Text   	 CreateFileA
DOUBLEWORD_BUFSIZE . . . . . . .	Number	 00000008h   
DO_NOT_SHARE . . . . . . . . . .	Number	 00000000h   
ENABLE_ECHO_INPUT  . . . . . . .	Number	 00000004h   
ENABLE_LINE_INPUT  . . . . . . .	Number	 00000002h   
ENABLE_MOUSE_INPUT . . . . . . .	Number	 00000010h   
ENABLE_PROCESSED_INPUT . . . . .	Number	 00000001h   
ENABLE_PROCESSED_OUTPUT  . . . .	Number	 00000001h   
ENABLE_WINDOW_INPUT  . . . . . .	Number	 00000008h   
ENABLE_WRAP_AT_EOL_OUTPUT  . . .	Number	 00000002h   
ENHANCED_KEY . . . . . . . . . .	Number	 00000100h   
FALSE  . . . . . . . . . . . . .	Number	 00000000h   
FILE_APPEND_DATA . . . . . . . .	Number	 00000004h   
FILE_ATTRIBUTE_ARCHIVE . . . . .	Number	 00000020h   
FILE_ATTRIBUTE_COMPRESSED  . . .	Number	 00000800h   
FILE_ATTRIBUTE_DEVICE  . . . . .	Number	 00000040h   
FILE_ATTRIBUTE_DIRECTORY . . . .	Number	 00000010h   
FILE_ATTRIBUTE_ENCRYPTED . . . .	Number	 00004000h   
FILE_ATTRIBUTE_HIDDEN  . . . . .	Number	 00000002h   
FILE_ATTRIBUTE_NORMAL  . . . . .	Number	 00000080h   
FILE_ATTRIBUTE_NOT_CONTENT_INDEXED .	Number	 00002000h   
FILE_ATTRIBUTE_OFFLINE . . . . .	Number	 00001000h   
FILE_ATTRIBUTE_READONLY  . . . .	Number	 00000001h   
FILE_ATTRIBUTE_REPARSE_POINT . .	Number	 00000400h   
FILE_ATTRIBUTE_SPARSE_FILE . . .	Number	 00000200h   
FILE_ATTRIBUTE_SYSTEM  . . . . .	Number	 00000004h   
FILE_ATTRIBUTE_TEMPORARY . . . .	Number	 00000100h   
FILE_BEGIN . . . . . . . . . . .	Number	 00000000h   
FILE_CURRENT . . . . . . . . . .	Number	 00000001h   
FILE_DELETE_CHILD  . . . . . . .	Number	 00000040h   
FILE_END . . . . . . . . . . . .	Number	 00000002h   
FILE_READ_DATA . . . . . . . . .	Number	 00000001h   
FILE_SHARE_DELETE  . . . . . . .	Number	 00000004h   
FILE_SHARE_READ  . . . . . . . .	Number	 00000001h   
FILE_SHARE_WRITE . . . . . . . .	Number	 00000002h   
FILE_WRITE_DATA  . . . . . . . .	Number	 00000002h   
FOCUS_EVENT  . . . . . . . . . .	Number	 00000010h   
FORMAT_MESSAGE_ALLOCATE_BUFFER .	Number	 00000100h   
FORMAT_MESSAGE_FROM_SYSTEM . . .	Number	 00001000h   
FormatMessage  . . . . . . . . .	Text   	 FormatMessageA
GENERIC_ALL  . . . . . . . . . .	Number	 10000000h   
GENERIC_EXECUTE  . . . . . . . .	Number	 20000000h   
GENERIC_READ . . . . . . . . . .	Number	 -80000000h   
GENERIC_WRITE  . . . . . . . . .	Number	 40000000h   
GetCommandLine . . . . . . . . .	Text   	 GetCommandLineA
HANDLE . . . . . . . . . . . . .	Text   	 DWORD
HEAP_GENERATE_EXCEPTIONS . . . .	Number	 00000004h   
HEAP_GROWABLE  . . . . . . . . .	Number	 00000002h   
HEAP_NO_SERIALIZE  . . . . . . .	Number	 00000001h   
HEAP_REALLOC_IN_PLACE_ONLY . . .	Number	 00000010h   
HEAP_ZERO_MEMORY . . . . . . . .	Number	 00000008h   
IDABORT  . . . . . . . . . . . .	Number	 00000003h   
IDCANCEL . . . . . . . . . . . .	Number	 00000002h   
IDCLOSE  . . . . . . . . . . . .	Number	 00000008h   
IDCONTINUE . . . . . . . . . . .	Number	 0000000Bh   
IDHELP . . . . . . . . . . . . .	Number	 00000009h   
IDIGNORE . . . . . . . . . . . .	Number	 00000005h   
IDNO . . . . . . . . . . . . . .	Number	 00000007h   
IDOK . . . . . . . . . . . . . .	Number	 00000001h   
IDRETRY  . . . . . . . . . . . .	Number	 00000004h   
IDTIMEOUT  . . . . . . . . . . .	Number	 00007D00h   
IDTRYAGAIN . . . . . . . . . . .	Number	 0000000Ah   
IDYES  . . . . . . . . . . . . .	Number	 00000006h   
INVALID_HANDLE_VALUE . . . . . .	Number	 -00000001h   
InitFlag . . . . . . . . . . . .	Byte	 00000000 _DATA	
KBDOWN_FLAG  . . . . . . . . . .	Number	 00000001h   
KEY_EVENT  . . . . . . . . . . .	Number	 00000001h   
KEY_MASKS  . . . . . . . . . . .	Number	 0000001Fh   
LEFT_ALT_PRESSED . . . . . . . .	Number	 00000002h   
LEFT_CTRL_PRESSED  . . . . . . .	Number	 00000008h   
LIGHT_BLUE . . . . . . . . . . .	Number	 00000009h   
LIGHT_CYAN . . . . . . . . . . .	Number	 0000000Bh   
LIGHT_GRAY . . . . . . . . . . .	Number	 00000007h   
LIGHT_GREEN  . . . . . . . . . .	Number	 0000000Ah   
LIGHT_MAGENTA  . . . . . . . . .	Number	 0000000Dh   
LIGHT_RED  . . . . . . . . . . .	Number	 0000000Ch   
LblEbpPtr  . . . . . . . . . . .	Byte	 000007EC _DATA	
LblEbp . . . . . . . . . . . . .	Byte	 000007D9 _DATA	
LblEsp . . . . . . . . . . . . .	Byte	 00000838 _DATA	
LblFor . . . . . . . . . . . . .	Byte	 000007D4 _DATA	
LblLocal . . . . . . . . . . . .	Byte	 00000814 _DATA	
LblParam . . . . . . . . . . . .	Byte	 000007DF _DATA	
LblReturn  . . . . . . . . . . .	Byte	 00000826 _DATA	
LblSaved . . . . . . . . . . . .	Byte	 00000802 _DATA	
LblStack . . . . . . . . . . . .	Byte	 000007C7 _DATA	
MAX_COLS . . . . . . . . . . . .	Number	 00000200h   
MAX_DIGITS . . . . . . . . . . .	Number	 00000050h   
MB_ABORTRETRYIGNORE  . . . . . .	Number	 00000002h   
MB_APPLMODAL . . . . . . . . . .	Number	 00000000h   
MB_CANCELTRYCONTINUE . . . . . .	Number	 00000006h   
MB_DEFBUTTON1  . . . . . . . . .	Number	 00000000h   
MB_DEFBUTTON2  . . . . . . . . .	Number	 00000100h   
MB_DEFBUTTON3  . . . . . . . . .	Number	 00000200h   
MB_DEFBUTTON4  . . . . . . . . .	Number	 00000300h   
MB_HELP  . . . . . . . . . . . .	Number	 00004000h   
MB_ICONASTERISK  . . . . . . . .	Number	 00000040h   
MB_ICONERROR . . . . . . . . . .	Number	 00000010h   
MB_ICONEXCLAMATION . . . . . . .	Number	 00000030h   
MB_ICONHAND  . . . . . . . . . .	Number	 00000010h   
MB_ICONINFORMATION . . . . . . .	Number	 00000040h   
MB_ICONQUESTION  . . . . . . . .	Number	 00000020h   
MB_ICONSTOP  . . . . . . . . . .	Number	 00000010h   
MB_ICONWARNING . . . . . . . . .	Number	 00000030h   
MB_OKCANCEL  . . . . . . . . . .	Number	 00000001h   
MB_OK  . . . . . . . . . . . . .	Number	 00000000h   
MB_RETRYCANCEL . . . . . . . . .	Number	 00000005h   
MB_SYSTEMMODAL . . . . . . . . .	Number	 00001000h   
MB_TASKMODAL . . . . . . . . . .	Number	 00002000h   
MB_USERICON  . . . . . . . . . .	Number	 00000080h   
MB_YESNOCANCEL . . . . . . . . .	Number	 00000003h   
MB_YESNO . . . . . . . . . . . .	Number	 00000004h   
MENU_EVENT . . . . . . . . . . .	Number	 00000008h   
MOUSE_EVENT  . . . . . . . . . .	Number	 00000002h   
MessageBox . . . . . . . . . . .	Text   	 MessageBoxA
NULL . . . . . . . . . . . . . .	Number	 00000000h   
NUMLOCK_ON . . . . . . . . . . .	Number	 00000020h   
NoNameCode . . . . . . . . . . .	Number	 00000001h   
NoName . . . . . . . . . . . . .	Byte	 0000085F _DATA	
OPEN_ALWAYS  . . . . . . . . . .	Number	 00000004h   
OPEN_EXISTING  . . . . . . . . .	Number	 00000003h   
PeekConsoleInput . . . . . . . .	Text   	 PeekConsoleInputA
QUOTE_MARK . . . . . . . . . . .	Number	 00000022h   
RIGHT_ALT_PRESSED  . . . . . . .	Number	 00000001h   
RIGHT_CTRL_PRESSED . . . . . . .	Number	 00000004h   
ReadConsoleInput . . . . . . . .	Text   	 ReadConsoleInputA
ReadConsole  . . . . . . . . . .	Text   	 ReadConsoleA
SCROLLLOCK_ON  . . . . . . . . .	Number	 00000040h   
SHIFT_MASK . . . . . . . . . . .	Number	 00000010h   
SHIFT_PRESSED  . . . . . . . . .	Number	 00000010h   
STD_ERROR_HANDLE . . . . . . . .	Number	 -0000000Ch   
STD_INPUT_HANDLE . . . . . . . .	Number	 -0000000Ah   
STD_OUTPUT_HANDLE  . . . . . . .	Number	 -0000000Bh   
SetConsoleTitle  . . . . . . . .	Text   	 SetConsoleTitleA
SpecialCases . . . . . . . . . .	Byte	 00000741 _DATA	
TAB  . . . . . . . . . . . . . .	Number	 00000009h   
TRUE . . . . . . . . . . . . . .	Number	 00000001h   
TRUNCATE_EXISTING  . . . . . . .	Number	 00000005h   
VK_11  . . . . . . . . . . . . .	Number	 000000BDh   
VK_12  . . . . . . . . . . . . .	Number	 000000BBh   
VK_ADD . . . . . . . . . . . . .	Number	 0000006Bh   
VK_BACK  . . . . . . . . . . . .	Number	 00000008h   
VK_CANCEL  . . . . . . . . . . .	Number	 00000003h   
VK_CAPITAL . . . . . . . . . . .	Number	 00000014h   
VK_CLEAR . . . . . . . . . . . .	Number	 0000000Ch   
VK_CONTROL . . . . . . . . . . .	Number	 00000011h   
VK_DECIMAL . . . . . . . . . . .	Number	 0000006Eh   
VK_DELETE  . . . . . . . . . . .	Number	 0000002Eh   
VK_DIVIDE  . . . . . . . . . . .	Number	 0000006Fh   
VK_DOWN  . . . . . . . . . . . .	Number	 00000028h   
VK_END . . . . . . . . . . . . .	Number	 00000023h   
VK_ESCAPE  . . . . . . . . . . .	Number	 0000001Bh   
VK_EXECUTE . . . . . . . . . . .	Number	 0000002Bh   
VK_F10 . . . . . . . . . . . . .	Number	 00000079h   
VK_F11 . . . . . . . . . . . . .	Number	 0000007Ah   
VK_F12 . . . . . . . . . . . . .	Number	 0000007Bh   
VK_F13 . . . . . . . . . . . . .	Number	 0000007Ch   
VK_F14 . . . . . . . . . . . . .	Number	 0000007Dh   
VK_F15 . . . . . . . . . . . . .	Number	 0000007Eh   
VK_F16 . . . . . . . . . . . . .	Number	 0000007Fh   
VK_F17 . . . . . . . . . . . . .	Number	 00000080h   
VK_F18 . . . . . . . . . . . . .	Number	 00000081h   
VK_F19 . . . . . . . . . . . . .	Number	 00000082h   
VK_F1  . . . . . . . . . . . . .	Number	 00000070h   
VK_F20 . . . . . . . . . . . . .	Number	 00000083h   
VK_F21 . . . . . . . . . . . . .	Number	 00000084h   
VK_F22 . . . . . . . . . . . . .	Number	 00000085h   
VK_F23 . . . . . . . . . . . . .	Number	 00000086h   
VK_F24 . . . . . . . . . . . . .	Number	 00000087h   
VK_F2  . . . . . . . . . . . . .	Number	 00000071h   
VK_F3  . . . . . . . . . . . . .	Number	 00000072h   
VK_F4  . . . . . . . . . . . . .	Number	 00000073h   
VK_F5  . . . . . . . . . . . . .	Number	 00000074h   
VK_F6  . . . . . . . . . . . . .	Number	 00000075h   
VK_F7  . . . . . . . . . . . . .	Number	 00000076h   
VK_F8  . . . . . . . . . . . . .	Number	 00000077h   
VK_F9  . . . . . . . . . . . . .	Number	 00000078h   
VK_HELP  . . . . . . . . . . . .	Number	 0000002Fh   
VK_HOME  . . . . . . . . . . . .	Number	 00000024h   
VK_INSERT  . . . . . . . . . . .	Number	 0000002Dh   
VK_LBUTTON . . . . . . . . . . .	Number	 00000001h   
VK_LCONTROL  . . . . . . . . . .	Number	 000000A2h   
VK_LEFT  . . . . . . . . . . . .	Number	 00000025h   
VK_LMENU . . . . . . . . . . . .	Number	 000000A4h   
VK_LSHIFT  . . . . . . . . . . .	Number	 000000A0h   
VK_MENU  . . . . . . . . . . . .	Number	 00000012h   
VK_MULTIPLY  . . . . . . . . . .	Number	 0000006Ah   
VK_NEXT  . . . . . . . . . . . .	Number	 00000022h   
VK_NUMLOCK . . . . . . . . . . .	Number	 00000090h   
VK_NUMPAD0 . . . . . . . . . . .	Number	 00000060h   
VK_NUMPAD1 . . . . . . . . . . .	Number	 00000061h   
VK_NUMPAD2 . . . . . . . . . . .	Number	 00000062h   
VK_NUMPAD3 . . . . . . . . . . .	Number	 00000063h   
VK_NUMPAD4 . . . . . . . . . . .	Number	 00000064h   
VK_NUMPAD5 . . . . . . . . . . .	Number	 00000065h   
VK_NUMPAD6 . . . . . . . . . . .	Number	 00000066h   
VK_NUMPAD7 . . . . . . . . . . .	Number	 00000067h   
VK_NUMPAD8 . . . . . . . . . . .	Number	 00000068h   
VK_NUMPAD9 . . . . . . . . . . .	Number	 00000069h   
VK_PAUSE . . . . . . . . . . . .	Number	 00000013h   
VK_PRINT . . . . . . . . . . . .	Number	 0000002Ah   
VK_PRIOR . . . . . . . . . . . .	Number	 00000021h   
VK_RBUTTON . . . . . . . . . . .	Number	 00000002h   
VK_RCONTROL  . . . . . . . . . .	Number	 000000A3h   
VK_RETURN  . . . . . . . . . . .	Number	 0000000Dh   
VK_RIGHT . . . . . . . . . . . .	Number	 00000027h   
VK_RMENU . . . . . . . . . . . .	Number	 000000A5h   
VK_RSHIFT  . . . . . . . . . . .	Number	 000000A1h   
VK_SCROLL  . . . . . . . . . . .	Number	 00000091h   
VK_SEPARATER . . . . . . . . . .	Number	 0000006Ch   
VK_SHIFT . . . . . . . . . . . .	Number	 00000010h   
VK_SNAPSHOT  . . . . . . . . . .	Number	 0000002Ch   
VK_SPACE . . . . . . . . . . . .	Number	 00000020h   
VK_SUBTRACT  . . . . . . . . . .	Number	 0000006Dh   
VK_TAB . . . . . . . . . . . . .	Number	 00000009h   
VK_UP  . . . . . . . . . . . . .	Number	 00000026h   
WDBUFFER_SIZE  . . . . . . . . .	Number	 0000000Ch   
WINDOW_BUFFER_SIZE_EVENT . . . .	Number	 00000004h   
WI_Bufsize . . . . . . . . . . .	Number	 0000000Ch   
WriteConsoleOutputCharacter  . .	Text   	 WriteConsoleOutputCharacterA
WriteConsole . . . . . . . . . .	Text   	 WriteConsoleA
WriteStackFrameNameSize  . . . .	Number	 00000040h   
WriteStackFrameSize  . . . . . .	Number	 00000014h   
WriteToFile_1  . . . . . . . . .	DWord	 00000860 _DATA	
WriteWindowsMsg_1  . . . . . . .	Byte	 00000864 _DATA	
WriteWindowsMsg_2  . . . . . . .	Byte	 0000086B _DATA	
_$$temp  . . . . . . . . . . . .	DWord	 00000782 _DATA	
_cursorPosition  . . . . . . . .	COORD	 000006D5 _DATA	
attribs  . . . . . . . . . . . .	Word	 00000211 _DATA	
black  . . . . . . . . . . . . .	Number	 00000000h   
blanks . . . . . . . . . . . . .	Byte	 00000011 _DATA	
blue . . . . . . . . . . . . . .	Number	 00000001h   
brown  . . . . . . . . . . . . .	Number	 00000006h   
bufferLHB  . . . . . . . . . . .	Byte	 000007B0 _DATA	
bufferL  . . . . . . . . . . . .	Byte	 000007A3 _DATA	
bufferMax  . . . . . . . . . . .	Number	 00000200h   
buffer_B . . . . . . . . . . . .	Byte	 000007B9 _DATA	
buffer . . . . . . . . . . . . .	Byte	 00000061 _BSS	
bytesRead  . . . . . . . . . . .	DWord	 00000261 _BSS	
bytesWritten . . . . . . . . . .	DWord	 00000008 _BSS	
charVal  . . . . . . . . . . . .	Byte	 0000072A _DATA	
consoleInHandle  . . . . . . . .	DWord	 00000000 _BSS	
consoleOutHandle . . . . . . . .	DWord	 00000004 _BSS	
count  . . . . . . . . . . . . .	DWord	 00000619 _DATA	
cursorLoc  . . . . . . . . . . .	COORD	 00000615 _DATA	
cyan . . . . . . . . . . . . . .	Number	 00000003h   
dashLine . . . . . . . . . . . .	Byte	 00000634 _DATA	
digitBuffer  . . . . . . . . . .	Byte	 00000010 _BSS	
dumpPrompt . . . . . . . . . . .	Byte	 00000622 _DATA	
eflags . . . . . . . . . . . . .	DWord	 0000000C _BSS	
evBuffer . . . . . . . . . . . .	INPUT_RECORD  0000072B _DATA	
evRepeat . . . . . . . . . . . .	Word	 0000073F _DATA	
exit . . . . . . . . . . . . . .	Text   	 INVOKE ExitProcess,0
gray . . . . . . . . . . . . . .	Number	 00000008h   
green  . . . . . . . . . . . . .	Number	 00000002h   
invalid_msgL . . . . . . . . . .	Byte	 000006F8 _DATA	
lightBlue  . . . . . . . . . . .	Number	 00000009h   
lightCyan  . . . . . . . . . . .	Number	 0000000Bh   
lightGray  . . . . . . . . . . .	Number	 00000007h   
lightGreen . . . . . . . . . . .	Number	 0000000Ah   
lightMagenta . . . . . . . . . .	Number	 0000000Dh   
lightRed . . . . . . . . . . . .	Number	 0000000Ch   
lineLength . . . . . . . . . . .	DWord	 00000611 _DATA	
magenta  . . . . . . . . . . . .	Number	 00000005h   
messageId  . . . . . . . . . . .	DWord	 00000872 _DATA	
neg_flag . . . . . . . . . . . .	Byte	 000007C6 _DATA	
numVal . . . . . . . . . . . . .	DWord	 00000726 _DATA	
oneSpace . . . . . . . . . . . .	Byte	 00000620 _DATA	
overflow_msgL  . . . . . . . . .	Byte	 000006DD _DATA	
pErrorMsg  . . . . . . . . . . .	DWord	 0000086E _DATA	
red  . . . . . . . . . . . . . .	Number	 00000004h   
saveESP  . . . . . . . . . . . .	DWord	 00000661 _DATA	
saveIP . . . . . . . . . . . . .	DWord	 0000065D _DATA	
seed . . . . . . . . . . . . . .	DWord	 0000070B _DATA	
sysTime  . . . . . . . . . . . .	SYSTEMTIME  00000265 _BSS	
waitmsgstr . . . . . . . . . . .	Byte	 00000786 _DATA	
white  . . . . . . . . . . . . .	Number	 0000000Fh   
wsprintf . . . . . . . . . . . .	Text   	 wsprintfA
xbtable  . . . . . . . . . . . .	Byte	 0000070F _DATA	
xtable . . . . . . . . . . . . .	Byte	 00000001 _DATA	
yellow . . . . . . . . . . . . .	Number	 0000000Eh   

	   0 Warnings
	   0 Errors
